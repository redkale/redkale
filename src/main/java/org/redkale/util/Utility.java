/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package org.redkale.util;

import java.io.*;
import java.lang.reflect.*;
import java.net.*;
import java.net.http.HttpClient;
import java.nio.*;
import java.nio.channels.CompletionHandler;
import java.nio.charset.*;
import static java.nio.charset.StandardCharsets.UTF_8;
import java.security.*;
import java.time.*;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.locks.ReentrantLock;
import java.util.function.*;
import java.util.stream.Stream;
import java.util.zip.GZIPInputStream;
import javax.crypto.*;
import javax.crypto.spec.SecretKeySpec;

/**
 *
 * 常见操作的工具类
 *
 * <p>
 * 详情见: https://redkale.org
 *
 * @author zhangjx
 */
public final class Utility {

    private static final int zoneRawOffset = TimeZone.getDefault().getRawOffset();

    static final String format1 = "%1$tY-%1$tm-%1$td %1$tH:%1$tM:%1$tS";   //yyyy-MM-dd HH:mm:ss

    static final String format2 = "%1$tY-%1$tm-%1$td %1$tH:%1$tM:%1$tS.%1$tL";  //yyyy-MM-dd HH:mm:ss.fff

    private static final char hex[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};

    private static final int cpus = Integer.getInteger("redkale.cpus", Runtime.getRuntime().availableProcessors());

    private static final int MAX_POW2 = 1 << 30;

    private static final Class JAVA_RECORD_CLASS;

    private static final SecureRandom random = new SecureRandom();

    private static final IntFunction<CompletableFuture[]> futureArrayFunc = c -> new CompletableFuture[c];

    private static final IntFunction<Serializable[]> serialArrayFunc = v -> new Serializable[v];

    static {
        Class clz = null;
        try {
            clz = Thread.currentThread().getContextClassLoader().loadClass("java.lang.Record");
        } catch (Throwable t) { //JDK14以下版本会异常
        }
        JAVA_RECORD_CLASS = clz;
    }

    //org.redkale.util.AnonymousVirtualExecutor
    private static final String functionVirtualExecutorBinary = "cafebabeffff0040008d0a000200030700040c000500060100106a6176612f6c616e672f4f626a6563740100063c696e69743e0100032829560a0008000907000a0c000b000c0100106a6176612f6c616e672f5468726561640100096f665669727475616c01002628294c6a6176612f6c616e672f546872656164244275696c646572244f665669727475616c3b0b000e000f0700100c001100120100226a6176612f6c616e672f546872656164244275696c646572244f665669727475616c010007666163746f727901002628294c6a6176612f7574696c2f636f6e63757272656e742f546872656164466163746f72793b0700140100296a6176612f7574696c2f636f6e63757272656e742f61746f6d69632f41746f6d6963496e74656765720a0013000312000000170c001800190100096e6577546872656164010087284c6a6176612f7574696c2f636f6e63757272656e742f546872656164466163746f72793b4c6a6176612f7574696c2f636f6e63757272656e742f61746f6d69632f41746f6d6963496e74656765723b4c6a6176612f6c616e672f537472696e673b294c6a6176612f7574696c2f636f6e63757272656e742f546872656164466163746f72793b0a001b001c07001d0c001e001f01001e6a6176612f7574696c2f636f6e63757272656e742f4578656375746f72730100186e65775468726561645065725461736b4578656375746f7201004c284c6a6176612f7574696c2f636f6e63757272656e742f546872656164466163746f72793b294c6a6176612f7574696c2f636f6e63757272656e742f4578656375746f72536572766963653b0700210100106a6176612f6c616e672f537472696e670a002300240700250c002600270100296f72672f7265646b616c652f7574696c2f416e6f6e796d6f75735669727475616c4578656375746f720100056170706c7901003a284c6a6176612f6c616e672f537472696e673b294c6a6176612f7574696c2f636f6e63757272656e742f4578656375746f72536572766963653b0b0029002a07002b0c0018002c0100226a6176612f7574696c2f636f6e63757272656e742f546872656164466163746f7279010028284c6a6176612f6c616e672f52756e6e61626c653b294c6a6176612f6c616e672f5468726561643b0a0013002e0c002f003001000f696e6372656d656e74416e6447657401000328294912000100320c003300340100176d616b65436f6e63617457697468436f6e7374616e74730100152849294c6a6176612f6c616e672f537472696e673b12000200320a003700380700390c003a003b0100116a6176612f6c616e672f496e746567657201000776616c75654f660100162849294c6a6176612f6c616e672f496e74656765723b0a0020003d0c003a003e010026284c6a6176612f6c616e672f4f626a6563743b294c6a6176612f6c616e672f537472696e673b12000300400c00330041010026284c6a6176612f6c616e672f537472696e673b294c6a6176612f6c616e672f537472696e673b0a002000430c00440045010006666f726d6174010039284c6a6176612f6c616e672f537472696e673b5b4c6a6176612f6c616e672f4f626a6563743b294c6a6176612f6c616e672f537472696e673b0a000800470c004800490100077365744e616d65010015284c6a6176612f6c616e672f537472696e673b295607004b01001b6a6176612f7574696c2f66756e6374696f6e2f46756e6374696f6e010004436f646501000f4c696e654e756d6265725461626c650100124c6f63616c5661726961626c655461626c650100047468697301002b4c6f72672f7265646b616c652f7574696c2f416e6f6e796d6f75735669727475616c4578656375746f723b0100107468726561644e616d65466f726d61740100124c6a6176612f6c616e672f537472696e673b0100244c6a6176612f7574696c2f636f6e63757272656e742f546872656164466163746f72793b010007636f756e74657201002b4c6a6176612f7574696c2f636f6e63757272656e742f61746f6d69632f41746f6d6963496e74656765723b0100104d6574686f64506172616d6574657273010026284c6a6176612f6c616e672f4f626a6563743b294c6a6176612f6c616e672f4f626a6563743b01000e6c616d626461246170706c792430010089284c6a6176612f7574696c2f636f6e63757272656e742f546872656164466163746f72793b4c6a6176612f7574696c2f636f6e63757272656e742f61746f6d69632f41746f6d6963496e74656765723b4c6a6176612f6c616e672f537472696e673b4c6a6176612f6c616e672f52756e6e61626c653b294c6a6176612f6c616e672f5468726561643b010001720100144c6a6176612f6c616e672f52756e6e61626c653b010001740100124c6a6176612f6c616e672f5468726561643b010001630100014901000d537461636b4d61705461626c650700620100126a6176612f6c616e672f52756e6e61626c650700640100135b4c6a6176612f6c616e672f4f626a6563743b0700660100146a6176612f696f2f53657269616c697a61626c650100095369676e61747572650100694c6a6176612f6c616e672f4f626a6563743b4c6a6176612f7574696c2f66756e6374696f6e2f46756e6374696f6e3c4c6a6176612f6c616e672f537472696e673b4c6a6176612f7574696c2f636f6e63757272656e742f4578656375746f72536572766963653b3e3b01000a536f7572636546696c6501001d416e6f6e796d6f75735669727475616c4578656375746f722e6a617661010010426f6f7473747261704d6574686f64730f06006d0a006e006f0700700c007100720100226a6176612f6c616e672f696e766f6b652f4c616d6264614d657461666163746f727901000b6d657461666163746f72790100cc284c6a6176612f6c616e672f696e766f6b652f4d6574686f6448616e646c6573244c6f6f6b75703b4c6a6176612f6c616e672f537472696e673b4c6a6176612f6c616e672f696e766f6b652f4d6574686f64547970653b4c6a6176612f6c616e672f696e766f6b652f4d6574686f64547970653b4c6a6176612f6c616e672f696e766f6b652f4d6574686f6448616e646c653b4c6a6176612f6c616e672f696e766f6b652f4d6574686f64547970653b294c6a6176612f6c616e672f696e766f6b652f43616c6c536974653b10002c0f0600750a002300760c005800590f0600780a0079007a07007b0c0033007c0100246a6176612f6c616e672f696e766f6b652f537472696e67436f6e636174466163746f7279010098284c6a6176612f6c616e672f696e766f6b652f4d6574686f6448616e646c6573244c6f6f6b75703b4c6a6176612f6c616e672f537472696e673b4c6a6176612f6c616e672f696e766f6b652f4d6574686f64547970653b4c6a6176612f6c616e672f537472696e673b5b4c6a6176612f6c616e672f4f626a6563743b294c6a6176612f6c616e672f696e766f6b652f43616c6c536974653b08007e01000330300108008001000230010800820100095669727475616c2d0101000c496e6e6572436c61737365730700850100186a6176612f6c616e672f546872656164244275696c6465720100074275696c6465720100094f665669727475616c0700890100256a6176612f6c616e672f696e766f6b652f4d6574686f6448616e646c6573244c6f6f6b757007008b01001e6a6176612f6c616e672f696e766f6b652f4d6574686f6448616e646c65730100064c6f6f6b75700021002300020001004a000000040001000500060001004c0000002f00010001000000052ab70001b100000002004d0000000600010000000e004e0000000c000100000005004f005000000001002600270002004c0000006d000300040000001db80007b9000d01004dbb001359b700154e2c2d2bba00160000b8001ab000000002004d0000000e0003000000120009001300110014004e0000002a00040000001d004f005000000000001d005100520001000900140011005300020011000c00540055000300560000000501005100001041002600570002004c0000003300020002000000092a2bc00020b60022b000000002004d0000000600010000000e004e0000000c000100000009004f005000000056000000050100511000100a005800590001004c0000013000070006000000512a2db9002802003a042bb6002d360519042c04bd000259031505100aa2000d1505ba00310000a7001915051064a2000d1505ba00350000a700081505b80036b8003cba003f000053b80042b600461904b000000003004d0000001200040000001500090016000f0017004e0018004e0000003e000600000051001100530000000000510054005500010000005100510052000200000051005a005b000300090048005c005d0004000f0042005e005f00050060000000710003ff0029000607002907001307002007006107000801000507000807002007006307006301ff0010000607002907001307002007006107000801000507000807002007006307006301ff000400060700290700130700200700610700080100060700080700200700630700630107006500040067000000020068006900000002006a006b0000001e0004006c000300730074007300770001007d00770001007f00770001008100830000001a00030084000800860609000e0084008706090088008a008c0019";

    private static final Function<String, ExecutorService> virtualExecutorFunction;

    //org.redkale.util.SignalShutDown
    private static final String consumerSignalShutdownBinary = "cafebabe00000037006b0a0019003a090018003b07003c08003d08003e08003f0800400800410800420800430800440800450700460a000d00470a000d004807004907004a0a000d004b0a000d004c12000000500b001600510700520a0018005307005407005507005601001073687574646f776e436f6e73756d657201001d4c6a6176612f7574696c2f66756e6374696f6e2f436f6e73756d65723b0100095369676e61747572650100314c6a6176612f7574696c2f66756e6374696f6e2f436f6e73756d65723c4c6a6176612f6c616e672f537472696e673b3e3b0100063c696e69743e010003282956010004436f646501000f4c696e654e756d6265725461626c650100124c6f63616c5661726961626c655461626c65010004746869730100214c6f72672f7265646b616c652f7574696c2f5369676e616c53687574446f776e3b010006616363657074010020284c6a6176612f7574696c2f66756e6374696f6e2f436f6e73756d65723b29560100037369670100124c6a6176612f6c616e672f537472696e673b010004736967730100135b4c6a6176612f6c616e672f537472696e673b010008636f6e73756d65720100164c6f63616c5661726961626c65547970655461626c6501000d537461636b4d61705461626c6507002b0100104d6574686f64506172616d6574657273010034284c6a6176612f7574696c2f66756e6374696f6e2f436f6e73756d65723c4c6a6176612f6c616e672f537472696e673b3e3b295601000668616e646c65010014284c73756e2f6d6973632f5369676e616c3b29560100114c73756e2f6d6973632f5369676e616c3b010006736967737472010015284c6a6176612f6c616e672f4f626a6563743b295601007a4c6a6176612f6c616e672f4f626a6563743b4c6a6176612f7574696c2f66756e6374696f6e2f436f6e73756d65723c4c6a6176612f7574696c2f66756e6374696f6e2f436f6e73756d65723c4c6a6176612f6c616e672f537472696e673b3e3b3e3b4c73756e2f6d6973632f5369676e616c48616e646c65723b01000a536f7572636546696c650100135369676e616c53687574446f776e2e6a6176610c001f00200c001b001c0100106a6176612f6c616e672f537472696e670100034855500100045445524d010003494e54010004515549540100044b494c4c01000454535450010004555352310100045553523201000453544f5001000f73756e2f6d6973632f5369676e616c0c001f00570c003200580100136a6176612f6c616e672f457863657074696f6e0100136a6176612f6c616e672f5468726f7761626c650c0059005a0c005b005c010010426f6f7473747261704d6574686f64730f06005d08005e0c005f00600c0026003601001b6a6176612f7574696c2f66756e6374696f6e2f436f6e73756d65720c0026002701001f6f72672f7265646b616c652f7574696c2f5369676e616c53687574446f776e0100106a6176612f6c616e672f4f626a65637401001673756e2f6d6973632f5369676e616c48616e646c6572010015284c6a6176612f6c616e672f537472696e673b2956010043284c73756e2f6d6973632f5369676e616c3b4c73756e2f6d6973632f5369676e616c48616e646c65723b294c73756e2f6d6973632f5369676e616c48616e646c65723b0100076765744e616d6501001428294c6a6176612f6c616e672f537472696e673b0100096765744e756d6265720100032829490a00610062010005012c012c010100176d616b65436f6e63617457697468436f6e7374616e7473010038284c73756e2f6d6973632f5369676e616c3b4c6a6176612f6c616e672f537472696e673b49294c6a6176612f6c616e672f537472696e673b0700630c005f00670100246a6176612f6c616e672f696e766f6b652f537472696e67436f6e636174466163746f72790700690100064c6f6f6b757001000c496e6e6572436c6173736573010098284c6a6176612f6c616e672f696e766f6b652f4d6574686f6448616e646c6573244c6f6f6b75703b4c6a6176612f6c616e672f537472696e673b4c6a6176612f6c616e672f696e766f6b652f4d6574686f64547970653b4c6a6176612f6c616e672f537472696e673b5b4c6a6176612f6c616e672f4f626a6563743b294c6a6176612f6c616e672f696e766f6b652f43616c6c536974653b07006a0100256a6176612f6c616e672f696e766f6b652f4d6574686f6448616e646c6573244c6f6f6b757001001e6a6176612f6c616e672f696e766f6b652f4d6574686f6448616e646c657300210018001900020016001a00010002001b001c0001001d00000002001e00040001001f0020000100210000002f00010001000000052ab70001b10000000200220000000600010000000c00230000000c000100000005002400250000000100260027000300210000014a000400080000006f2a2bb500021009bd0003590312045359041205535905120653590612075359071208535908120953591006120a53591007120b53591008120c534d2c4e2dbe360403360515051504a200222d1505323a06bb000d591906b7000e2ab8000f57a700053a07840501a7ffdda700044db100020051005f006200100005006a006d0011000400220000002a000a0000001200050014003b001500510017005f00190062001800640015006a001c006d001b006e001d00230000002a000400510013002800290006003b002f002a002b00020000006f0024002500000000006f002c001c0001002d0000000c00010000006f002c001e0001002e000000470006ff0044000607001807001607002f07002f01010000ff001d000707001807001607002f07002f01010700030001070010fa0001ff000500020700180700160000420700110000300000000501002c0000001d0000000200310021003200330002002100000060000300030000001a2b2bb600122bb60013ba001400004d2ab400022cb900150200b10000000200220000000e000300000021000f00220019002300230000002000030000001a0024002500000000001a002800340001000f000b0035002900020030000000050100280000104100260036000200210000003300020002000000092a2bc00016b60017b10000000200220000000600010000000c00230000000c00010000000900240025000000300000000501002c10000004001d000000020037003800000002003900660000000a00010064006800650019004d000000080001004e0001004f";

    private static final Consumer<Consumer<String>> signalShutdownConsumer;

    //org.redkale.util.AnonymousUnsafe
    private static final String funcAnonymousUnsafeBinary = "cafebabe0000003701710a000200030700040c000500060100106a6176612f6c616e672f4f626a6563740100063c696e69743e01000328295607000801000f73756e2f6d6973632f556e7361666509000a000b07000c0c000d000e0100206f72672f7265646b616c652f7574696c2f416e6f6e796d6f7573556e73616665010006756e736166650100114c73756e2f6d6973632f556e736166653b0a000700100c00110012010006676574496e74010016284c6a6176612f6c616e672f4f626a6563743b4a29490a000700140c00150016010006707574496e74010017284c6a6176612f6c616e672f4f626a6563743b4a4929560a000700180c0019001a0100096765744f626a656374010027284c6a6176612f6c616e672f4f626a6563743b4a294c6a6176612f6c616e672f4f626a6563743b0a0007001c0c001d001e0100097075744f626a656374010028284c6a6176612f6c616e672f4f626a6563743b4a4c6a6176612f6c616e672f4f626a6563743b29560a000700200c0021002201000a676574426f6f6c65616e010016284c6a6176612f6c616e672f4f626a6563743b4a295a0a000700240c0025002601000a707574426f6f6c65616e010017284c6a6176612f6c616e672f4f626a6563743b4a5a29560a000700280c0029002a01000767657442797465010016284c6a6176612f6c616e672f4f626a6563743b4a29420a0007002c0c002d002e01000770757442797465010017284c6a6176612f6c616e672f4f626a6563743b4a4229560a000700300c0031003201000867657453686f7274010016284c6a6176612f6c616e672f4f626a6563743b4a29530a000700340c0035003601000870757453686f7274010017284c6a6176612f6c616e672f4f626a6563743b4a5329560a000700380c0039003a01000767657443686172010016284c6a6176612f6c616e672f4f626a6563743b4a29430a0007003c0c003d003e01000770757443686172010017284c6a6176612f6c616e672f4f626a6563743b4a4329560a000700400c004100420100076765744c6f6e67010016284c6a6176612f6c616e672f4f626a6563743b4a294a0a000700440c004500460100077075744c6f6e67010017284c6a6176612f6c616e672f4f626a6563743b4a4a29560a000700480c0049004a010008676574466c6f6174010016284c6a6176612f6c616e672f4f626a6563743b4a29460a0007004c0c004d004e010008707574466c6f6174010017284c6a6176612f6c616e672f4f626a6563743b4a4629560a000700500c00510052010009676574446f75626c65010016284c6a6176612f6c616e672f4f626a6563743b4a29440a000700540c00550056010009707574446f75626c65010017284c6a6176612f6c616e672f4f626a6563743b4a4429560a000700580c00290059010004284a29420a0007005b0c002d005c010005284a4229560a0007005e0c0031005f010004284a29530a000700610c00350062010005284a5329560a000700640c00390065010004284a29430a000700670c003d0068010005284a4329560a0007006a0c0011006b010004284a29490a0007006d0c0015006e010005284a4929560a000700700c00410071010004284a294a0a000700730c00450074010005284a4a29560a000700760c00490077010004284a29460a000700790c004d007a010005284a4629560a0007007c0c0051007d010004284a29440a0007007f0c00550080010005284a4429560a000700820c0083007101000a676574416464726573730a000700850c0086007401000a707574416464726573730a000700880c0089007101000e616c6c6f636174654d656d6f72790a0007008b0c008c008d0100107265616c6c6f636174654d656d6f7279010005284a4a294a0a0007008f0c009000910100097365744d656d6f7279010018284c6a6176612f6c616e672f4f626a6563743b4a4a4229560a000700930c00900094010006284a4a4229560a000700960c0097009801000a636f70794d656d6f727901002a284c6a6176612f6c616e672f4f626a6563743b4a4c6a6176612f6c616e672f4f626a6563743b4a4a29560a0007009a0c0097009b010006284a4a4a29560a0007009d0c009e009f01000a667265654d656d6f7279010004284a29560a000700a10c00a200a30100116f626a6563744669656c644f666673657401001c284c6a6176612f6c616e672f7265666c6563742f4669656c643b294a0a000700a50c00a600a30100117374617469634669656c644f66667365740a000700a80c00a900aa01000f7374617469634669656c644261736501002d284c6a6176612f6c616e672f7265666c6563742f4669656c643b294c6a6176612f6c616e672f4f626a6563743b0a000700ac0c00ad00ae01000f6172726179426173654f6666736574010014284c6a6176612f6c616e672f436c6173733b29490a000700b00c00b100ae01000f6172726179496e6465785363616c650a000700b30c00b400b501000b6164647265737353697a650100032829490a000700b70c00b800b50100087061676553697a650a000700ba0c00bb00bc010010616c6c6f63617465496e7374616e6365010025284c6a6176612f6c616e672f436c6173733b294c6a6176612f6c616e672f4f626a6563743b0a000700be0c00bf00c001000e7468726f77457863657074696f6e010018284c6a6176612f6c616e672f5468726f7761626c653b29560a000700c20c00c300c4010014636f6d70617265416e64537761704f626a65637401003a284c6a6176612f6c616e672f4f626a6563743b4a4c6a6176612f6c616e672f4f626a6563743b4c6a6176612f6c616e672f4f626a6563743b295a0a000700c60c00c700c8010011636f6d70617265416e6453776170496e74010018284c6a6176612f6c616e672f4f626a6563743b4a4949295a0a000700ca0c00cb00cc010012636f6d70617265416e64537761704c6f6e67010018284c6a6176612f6c616e672f4f626a6563743b4a4a4a295a0a000700ce0c00cf001a0100116765744f626a656374566f6c6174696c650a000700d10c00d2001e0100117075744f626a656374566f6c6174696c650a000700d40c00d5001201000e676574496e74566f6c6174696c650a000700d70c00d8001601000e707574496e74566f6c6174696c650a000700da0c00db0022010012676574426f6f6c65616e566f6c6174696c650a000700dd0c00de0026010012707574426f6f6c65616e566f6c6174696c650a000700e00c00e1002a01000f67657442797465566f6c6174696c650a000700e30c00e4002e01000f70757442797465566f6c6174696c650a000700e60c00e7003201001067657453686f7274566f6c6174696c650a000700e90c00ea003601001070757453686f7274566f6c6174696c650a000700ec0c00ed003a01000f67657443686172566f6c6174696c650a000700ef0c00f0003e01000f70757443686172566f6c6174696c650a000700f20c00f3004201000f6765744c6f6e67566f6c6174696c650a000700f50c00f6004601000f7075744c6f6e67566f6c6174696c650a000700f80c00f9004a010010676574466c6f6174566f6c6174696c650a000700fb0c00fc004e010010707574466c6f6174566f6c6174696c650a000700fe0c00ff0052010011676574446f75626c65566f6c6174696c650a000701010c01020056010011707574446f75626c65566f6c6174696c650a000701040c0105001e0100107075744f7264657265644f626a6563740a000701070c0108001601000d7075744f726465726564496e740a0007010a0c010b004601000e7075744f7264657265644c6f6e670a0007010d0c010e010f010006756e7061726b010015284c6a6176612f6c616e672f4f626a6563743b29560a000701110c011201130100047061726b010005285a4a29560a000701150c0116011701000e6765744c6f616441766572616765010006285b444929490a000701190c011a011b01000c676574416e64416464496e74010017284c6a6176612f6c616e672f4f626a6563743b4a4929490a0007011d0c011e011f01000d676574416e644164644c6f6e67010017284c6a6176612f6c616e672f4f626a6563743b4a4a294a0a000701210c0122011b01000c676574416e64536574496e740a000701240c0125011f01000d676574416e645365744c6f6e670a000701270c0128012901000f676574416e645365744f626a656374010039284c6a6176612f6c616e672f4f626a6563743b4a4c6a6176612f6c616e672f4f626a6563743b294c6a6176612f6c616e672f4f626a6563743b0a0007012b0c012c00060100096c6f616446656e63650a0007012e0c012f000601000a73746f726546656e63650a000701310c0132000601000966756c6c46656e63650a000701340c0135013601000d696e766f6b65436c65616e6572010018284c6a6176612f6e696f2f427974654275666665723b29560701380100176f72672f7265646b616c652f7574696c2f556e73616665010004436f646501000f4c696e654e756d6265725461626c650100124c6f63616c5661726961626c655461626c65010004746869730100224c6f72672f7265646b616c652f7574696c2f416e6f6e796d6f7573556e736166653b0100036f626a0100124c6a6176612f6c616e672f4f626a6563743b0100104d6574686f64506172616d65746572730100016f0100066f66667365740100014a01000178010001490100015a010001420100015301000143010001460100014401000761646472657373010005627974657301000576616c7565010007737263426173650100097372634f6666736574010008646573744261736501000a646573744f666673657401000a7372634164647265737301000b6465737441646472657373010001660100194c6a6176612f6c616e672f7265666c6563742f4669656c643b01000a6172726179436c6173730100114c6a6176612f6c616e672f436c6173733b0100164c6f63616c5661726961626c65547970655461626c650100144c6a6176612f6c616e672f436c6173733c2a3e3b0100095369676e6174757265010017284c6a6176612f6c616e672f436c6173733c2a3e3b2949010003636c7301000a457863657074696f6e730701600100206a6176612f6c616e672f496e7374616e74696174696f6e457863657074696f6e010028284c6a6176612f6c616e672f436c6173733c2a3e3b294c6a6176612f6c616e672f4f626a6563743b01000265650100154c6a6176612f6c616e672f5468726f7761626c653b010008657870656374656401000674687265616401000a69734162736f6c75746501000474696d650100076c6f61646176670100025b440100066e656c656d7301000564656c74610100086e657756616c756501000c6469726563744275666665720100154c6a6176612f6e696f2f427974654275666665723b01000a536f7572636546696c65010014416e6f6e796d6f7573556e736166652e6a6176610021000a00020001013700010012000d000e0000005700010005010f0002013900000049000200020000000d2ab700012a2bc00007b50009b100000002013a0000000e00030000000a0004000b000c000c013b0000001600020000000d013c013d00000000000d013e013f000101400000000501013e00000001001100120002013900000048000400040000000a2ab400092b20b6000fac00000002013a00000006000100000010013b0000002000030000000a013c013d00000000000a0141013f00010000000a0142014300020140000000090201410000014200000001001500160002013900000058000500050000000c2ab400092b201504b60013b100000002013a0000000a000200000015000b0016013b0000002a00040000000c013c013d00000000000c0141013f00010000000c0142014300020000000c01440145000401400000000d0301410000014200000144000000010019001a0002013900000048000400040000000a2ab400092b20b60017b000000002013a0000000600010000001a013b0000002000030000000a013c013d00000000000a0141013f00010000000a0142014300020140000000090201410000014200000001001d001e0002013900000058000500050000000c2ab400092b201904b6001bb100000002013a0000000a00020000001f000b0020013b0000002a00040000000c013c013d00000000000c0141013f00010000000c0142014300020000000c0144013f000401400000000d030141000001420000014400000001002100220002013900000048000400040000000a2ab400092b20b6001fac00000002013a00000006000100000024013b0000002000030000000a013c013d00000000000a0141013f00010000000a0142014300020140000000090201410000014200000001002500260002013900000058000500050000000c2ab400092b201504b60023b100000002013a0000000a000200000029000b002a013b0000002a00040000000c013c013d00000000000c0141013f00010000000c0142014300020000000c01440146000401400000000d0301410000014200000144000000010029002a0002013900000048000400040000000a2ab400092b20b60027ac00000002013a0000000600010000002e013b0000002000030000000a013c013d00000000000a0141013f00010000000a0142014300020140000000090201410000014200000001002d002e0002013900000058000500050000000c2ab400092b201504b6002bb100000002013a0000000a000200000033000b0034013b0000002a00040000000c013c013d00000000000c0141013f00010000000c0142014300020000000c01440147000401400000000d030141000001420000014400000001003100320002013900000048000400040000000a2ab400092b20b6002fac00000002013a00000006000100000038013b0000002000030000000a013c013d00000000000a0141013f00010000000a0142014300020140000000090201410000014200000001003500360002013900000058000500050000000c2ab400092b201504b60033b100000002013a0000000a00020000003d000b003e013b0000002a00040000000c013c013d00000000000c0141013f00010000000c0142014300020000000c01440148000401400000000d0301410000014200000144000000010039003a0002013900000048000400040000000a2ab400092b20b60037ac00000002013a00000006000100000042013b0000002000030000000a013c013d00000000000a0141013f00010000000a0142014300020140000000090201410000014200000001003d003e0002013900000058000500050000000c2ab400092b201504b6003bb100000002013a0000000a000200000047000b0048013b0000002a00040000000c013c013d00000000000c0141013f00010000000c0142014300020000000c01440149000401400000000d030141000001420000014400000001004100420002013900000048000400040000000a2ab400092b20b6003fad00000002013a0000000600010000004c013b0000002000030000000a013c013d00000000000a0141013f00010000000a0142014300020140000000090201410000014200000001004500460002013900000058000600060000000c2ab400092b201604b60043b100000002013a0000000a000200000051000b0052013b0000002a00040000000c013c013d00000000000c0141013f00010000000c0142014300020000000c01440143000401400000000d0301410000014200000144000000010049004a0002013900000048000400040000000a2ab400092b20b60047ae00000002013a00000006000100000056013b0000002000030000000a013c013d00000000000a0141013f00010000000a0142014300020140000000090201410000014200000001004d004e0002013900000058000500050000000c2ab400092b201704b6004bb100000002013a0000000a00020000005b000b005c013b0000002a00040000000c013c013d00000000000c0141013f00010000000c0142014300020000000c0144014a000401400000000d030141000001420000014400000001005100520002013900000048000400040000000a2ab400092b20b6004faf00000002013a00000006000100000060013b0000002000030000000a013c013d00000000000a0141013f00010000000a0142014300020140000000090201410000014200000001005500560002013900000058000600060000000c2ab400092b201804b60053b100000002013a0000000a000200000065000b0066013b0000002a00040000000c013c013d00000000000c0141013f00010000000c0142014300020000000c0144014b000401400000000d03014100000142000001440000000100290059000201390000003d00030003000000092ab400091fb60057ac00000002013a0000000600010000006a013b00000016000200000009013c013d000000000009014c0143000101400000000501014c00000001002d005c000201390000004c000400040000000a2ab400091f1db6005ab100000002013a0000000a00020000006f00090070013b0000002000030000000a013c013d00000000000a014c014300010000000a01440147000301400000000902014c00000144000000010031005f000201390000003d00030003000000092ab400091fb6005dac00000002013a00000006000100000074013b00000016000200000009013c013d000000000009014c0143000101400000000501014c0000000100350062000201390000004c000400040000000a2ab400091f1db60060b100000002013a0000000a0002000000790009007a013b0000002000030000000a013c013d00000000000a014c014300010000000a01440148000301400000000902014c000001440000000100390065000201390000003d00030003000000092ab400091fb60063ac00000002013a0000000600010000007e013b00000016000200000009013c013d000000000009014c0143000101400000000501014c00000001003d0068000201390000004c000400040000000a2ab400091f1db60066b100000002013a0000000a00020000008300090084013b0000002000030000000a013c013d00000000000a014c014300010000000a01440149000301400000000902014c00000144000000010011006b000201390000003d00030003000000092ab400091fb60069ac00000002013a00000006000100000088013b00000016000200000009013c013d000000000009014c0143000101400000000501014c000000010015006e000201390000004c000400040000000a2ab400091f1db6006cb100000002013a0000000a00020000008d0009008e013b0000002000030000000a013c013d00000000000a014c014300010000000a01440145000301400000000902014c000001440000000100410071000201390000003d00030003000000092ab400091fb6006fad00000002013a00000006000100000092013b00000016000200000009013c013d000000000009014c0143000101400000000501014c0000000100450074000201390000004c000500050000000a2ab400091f21b60072b100000002013a0000000a00020000009700090098013b0000002000030000000a013c013d00000000000a014c014300010000000a01440143000301400000000902014c000001440000000100490077000201390000003d00030003000000092ab400091fb60075ae00000002013a0000000600010000009c013b00000016000200000009013c013d000000000009014c0143000101400000000501014c00000001004d007a000201390000004c000400040000000a2ab400091f25b60078b100000002013a0000000a0002000000a1000900a2013b0000002000030000000a013c013d00000000000a014c014300010000000a0144014a000301400000000902014c00000144000000010051007d000201390000003d00030003000000092ab400091fb6007baf00000002013a000000060001000000a6013b00000016000200000009013c013d000000000009014c0143000101400000000501014c0000000100550080000201390000004c000500050000000a2ab400091f29b6007eb100000002013a0000000a0002000000ab000900ac013b0000002000030000000a013c013d00000000000a014c014300010000000a0144014b000301400000000902014c000001440000000100830071000201390000003d00030003000000092ab400091fb60081ad00000002013a000000060001000000b0013b00000016000200000009013c013d000000000009014c0143000101400000000501014c0000000100860074000201390000004c000500050000000a2ab400091f21b60084b100000002013a0000000a0002000000b5000900b6013b0000002000030000000a013c013d00000000000a014c014300010000000a01440143000301400000000902014c000001440000000100890071000201390000003d00030003000000092ab400091fb60087ad00000002013a000000060001000000ba013b00000016000200000009013c013d000000000009014d0143000101400000000501014d00000001008c008d0002013900000048000500050000000a2ab400091f21b6008aad00000002013a000000060001000000bf013b0000002000030000000a013c013d00000000000a014c014300010000000a014d0143000301400000000902014c0000014d00000001009000910002013900000064000700070000000e2ab400092b2016041506b6008eb100000002013a0000000a0002000000c4000d00c5013b0000003400050000000e013c013d00000000000e0141013f00010000000e0142014300020000000e014d014300040000000e014e01470006014000000011040141000001420000014d0000014e00000001009000940002013900000058000600060000000c2ab400091f211505b60092b100000002013a0000000a0002000000c9000b00ca013b0000002a00040000000c013c013d00000000000c014c014300010000000c014d014300030000000c014e0147000501400000000d03014c0000014d0000014e0000000100970098000201390000007000090009000000102ab400092b20190416051607b60095b100000002013a0000000a0002000000ce000f00cf013b0000003e000600000010013c013d000000000010014f013f000100000010015001430002000000100151013f00040000001001520143000500000010014d0143000701400000001505014f0000015000000151000001520000014d000000010097009b0002013900000058000700070000000c2ab400091f211605b60099b100000002013a0000000a0002000000d3000b00d4013b0000002a00040000000c013c013d00000000000c0153014300010000000c0154014300030000000c014d0143000501400000000d030153000001540000014d00000001009e009f000201390000004100030003000000092ab400091fb6009cb100000002013a0000000a0002000000d8000800d9013b00000016000200000009013c013d000000000009014c0143000101400000000501014c0000000100a200a3000201390000003d00020002000000092ab400092bb600a0ad00000002013a000000060001000000dd013b00000016000200000009013c013d0000000000090155015600010140000000050101550000000100a600a3000201390000003d00020002000000092ab400092bb600a4ad00000002013a000000060001000000e2013b00000016000200000009013c013d0000000000090155015600010140000000050101550000000100a900aa000201390000003d00020002000000092ab400092bb600a7b000000002013a000000060001000000e7013b00000016000200000009013c013d0000000000090155015600010140000000050101550000000100ad00ae000301390000004f00020002000000092ab400092bb600abac00000003013a000000060001000000ec013b00000016000200000009013c013d00000000000901570158000101590000000c0001000000090157015a00010140000000050101570000015b00000002015c000100b100ae000301390000004f00020002000000092ab400092bb600afac00000003013a000000060001000000f1013b00000016000200000009013c013d00000000000901570158000101590000000c0001000000090157015a00010140000000050101570000015b00000002015c000100b400b5000101390000003200010001000000082ab40009b600b2ac00000002013a000000060001000000f6013b0000000c000100000008013c013d0000000100b800b5000101390000003200010001000000082ab40009b600b6ac00000002013a000000060001000000fb013b0000000c000100000008013c013d0000000100bb00bc000401390000004f00020002000000092ab400092bb600b9b000000003013a00000006000100000100013b00000016000200000009013c013d000000000009015d0158000101590000000c000100000009015d015a0001015e000000040001015f01400000000501015d0000015b000000020161000100bf00c0000201390000004100020002000000092ab400092bb600bdb100000002013a0000000a00020000010500080106013b00000016000200000009013c013d0000000000090162016300010140000000050101620000000100c300c40002013900000060000600060000000e2ab400092b2019041905b600c1ac00000002013a0000000600010000010a013b0000003400050000000e013c013d00000000000e0141013f00010000000e0142014300020000000e0164013f00040000000e0144013f00050140000000110401410000014200000164000001440000000100c700c80002013900000060000600060000000e2ab400092b2015041505b600c5ac00000002013a0000000600010000010f013b0000003400050000000e013c013d00000000000e0141013f00010000000e0142014300020000000e0164014500040000000e0144014500050140000000110401410000014200000164000001440000000100cb00cc0002013900000060000800080000000e2ab400092b2016041606b600c9ac00000002013a00000006000100000114013b0000003400050000000e013c013d00000000000e0141013f00010000000e0142014300020000000e0164014300040000000e0144014300060140000000110401410000014200000164000001440000000100cf001a0002013900000048000400040000000a2ab400092b20b600cdb000000002013a00000006000100000119013b0000002000030000000a013c013d00000000000a0141013f00010000000a014201430002014000000009020141000001420000000100d2001e0002013900000058000500050000000c2ab400092b201904b600d0b100000002013a0000000a00020000011e000b011f013b0000002a00040000000c013c013d00000000000c0141013f00010000000c0142014300020000000c0144013f000401400000000d03014100000142000001440000000100d500120002013900000048000400040000000a2ab400092b20b600d3ac00000002013a00000006000100000123013b0000002000030000000a013c013d00000000000a0141013f00010000000a014201430002014000000009020141000001420000000100d800160002013900000058000500050000000c2ab400092b201504b600d6b100000002013a0000000a000200000128000b0129013b0000002a00040000000c013c013d00000000000c0141013f00010000000c0142014300020000000c01440145000401400000000d03014100000142000001440000000100db00220002013900000048000400040000000a2ab400092b20b600d9ac00000002013a0000000600010000012d013b0000002000030000000a013c013d00000000000a0141013f00010000000a014201430002014000000009020141000001420000000100de00260002013900000058000500050000000c2ab400092b201504b600dcb100000002013a0000000a000200000132000b0133013b0000002a00040000000c013c013d00000000000c0141013f00010000000c0142014300020000000c01440146000401400000000d03014100000142000001440000000100e1002a0002013900000048000400040000000a2ab400092b20b600dfac00000002013a00000006000100000137013b0000002000030000000a013c013d00000000000a0141013f00010000000a014201430002014000000009020141000001420000000100e4002e0002013900000058000500050000000c2ab400092b201504b600e2b100000002013a0000000a00020000013c000b013d013b0000002a00040000000c013c013d00000000000c0141013f00010000000c0142014300020000000c01440147000401400000000d03014100000142000001440000000100e700320002013900000048000400040000000a2ab400092b20b600e5ac00000002013a00000006000100000141013b0000002000030000000a013c013d00000000000a0141013f00010000000a014201430002014000000009020141000001420000000100ea00360002013900000058000500050000000c2ab400092b201504b600e8b100000002013a0000000a000200000146000b0147013b0000002a00040000000c013c013d00000000000c0141013f00010000000c0142014300020000000c01440148000401400000000d03014100000142000001440000000100ed003a0002013900000048000400040000000a2ab400092b20b600ebac00000002013a0000000600010000014b013b0000002000030000000a013c013d00000000000a0141013f00010000000a014201430002014000000009020141000001420000000100f0003e0002013900000058000500050000000c2ab400092b201504b600eeb100000002013a0000000a000200000150000b0151013b0000002a00040000000c013c013d00000000000c0141013f00010000000c0142014300020000000c01440149000401400000000d03014100000142000001440000000100f300420002013900000048000400040000000a2ab400092b20b600f1ad00000002013a00000006000100000155013b0000002000030000000a013c013d00000000000a0141013f00010000000a014201430002014000000009020141000001420000000100f600460002013900000058000600060000000c2ab400092b201604b600f4b100000002013a0000000a00020000015a000b015b013b0000002a00040000000c013c013d00000000000c0141013f00010000000c0142014300020000000c01440143000401400000000d03014100000142000001440000000100f9004a0002013900000048000400040000000a2ab400092b20b600f7ae00000002013a0000000600010000015f013b0000002000030000000a013c013d00000000000a0141013f00010000000a014201430002014000000009020141000001420000000100fc004e0002013900000058000500050000000c2ab400092b201704b600fab100000002013a0000000a000200000164000b0165013b0000002a00040000000c013c013d00000000000c0141013f00010000000c0142014300020000000c0144014a000401400000000d03014100000142000001440000000100ff00520002013900000048000400040000000a2ab400092b20b600fdaf00000002013a00000006000100000169013b0000002000030000000a013c013d00000000000a0141013f00010000000a0142014300020140000000090201410000014200000001010200560002013900000058000600060000000c2ab400092b201804b60100b100000002013a0000000a00020000016e000b016f013b0000002a00040000000c013c013d00000000000c0141013f00010000000c0142014300020000000c0144014b000401400000000d0301410000014200000144000000010105001e0002013900000058000500050000000c2ab400092b201904b60103b100000002013a0000000a000200000173000b0174013b0000002a00040000000c013c013d00000000000c0141013f00010000000c0142014300020000000c0144013f000401400000000d030141000001420000014400000001010800160002013900000058000500050000000c2ab400092b201504b60106b100000002013a0000000a000200000178000b0179013b0000002a00040000000c013c013d00000000000c0141013f00010000000c0142014300020000000c01440145000401400000000d030141000001420000014400000001010b00460002013900000058000600060000000c2ab400092b201604b60109b100000002013a0000000a00020000017d000b017e013b0000002a00040000000c013c013d00000000000c0141013f00010000000c0142014300020000000c01440143000401400000000d030141000001420000014400000001010e010f000201390000004100020002000000092ab400092bb6010cb100000002013a0000000a00020000018200080183013b00000016000200000009013c013d0000000000090165013f00010140000000050101650000000101120113000201390000004c000400040000000a2ab400091b20b60110b100000002013a0000000a00020000018700090188013b0000002000030000000a013c013d00000000000a0166014600010000000a0167014300020140000000090201660000016700000001011601170002013900000048000300030000000a2ab400092b1cb60114ac00000002013a0000000600010000018c013b0000002000030000000a013c013d00000000000a0168016900010000000a016a014500020140000000090201680000016a00000001011a011b0002013900000054000500050000000c2ab400092b201504b60118ac00000002013a00000006000100000191013b0000002a00040000000c013c013d00000000000c0141013f00010000000c0142014300020000000c016b0145000401400000000d030141000001420000016b00000001011e011f0002013900000054000600060000000c2ab400092b201604b6011cad00000002013a00000006000100000196013b0000002a00040000000c013c013d00000000000c0141013f00010000000c0142014300020000000c016b0143000401400000000d030141000001420000016b000000010122011b0002013900000054000500050000000c2ab400092b201504b60120ac00000002013a0000000600010000019b013b0000002a00040000000c013c013d00000000000c0141013f00010000000c0142014300020000000c016c0145000401400000000d030141000001420000016c000000010125011f0002013900000054000600060000000c2ab400092b201604b60123ad00000002013a000000060001000001a0013b0000002a00040000000c013c013d00000000000c0141013f00010000000c0142014300020000000c016c0143000401400000000d030141000001420000016c00000001012801290002013900000054000500050000000c2ab400092b201904b60126b000000002013a000000060001000001a5013b0000002a00040000000c013c013d00000000000c0141013f00010000000c0142014300020000000c016c013f000401400000000d030141000001420000016c00000001012c0006000101390000003600010001000000082ab40009b6012ab100000002013a0000000a0002000001aa000701ab013b0000000c000100000008013c013d00000001012f0006000101390000003600010001000000082ab40009b6012db100000002013a0000000a0002000001af000701b0013b0000000c000100000008013c013d0000000101320006000101390000003600010001000000082ab40009b60130b100000002013a0000000a0002000001b4000701b5013b0000000c000100000008013c013d0000000101350136000201390000004100020002000000092ab400092bb60133b100000002013a0000000a0002000001b9000801ba013b00000016000200000009013c013d000000000009016d016e000101400000000501016d00000001016f000000020170";

    private static final Unsafe unsafeInstance;

    //-------------------------------------------------------------------------------
    private static final Function<Object, Object> strByteFunction;

    private static final Function<Object, Object> sbByteFunction;

    private static final Function<Object, Object> strCharFunction;

    private static final Function<Object, Object> sbCharFunction;

    private static final Predicate<Object> strLatin1Function;

    private static final ToLongFunction<Object> bufferAddrFunction;

    private static final ReentrantLock clientLock = new ReentrantLock();

    private static HttpClient httpClient;

    //private static final javax.net.ssl.SSLContext DEFAULTSSL_CONTEXT;
    //private static final javax.net.ssl.HostnameVerifier defaultVerifier = (s, ss) -> true;
    static {
        System.setProperty("jdk.httpclient.allowRestrictedHeaders", "host");
        Unsafe unsafe0 = null;
        Function<Object, Object> strCharFunction0 = null;
        Function<Object, Object> sbCharFunction0 = null;
        Function<Object, Object> strByteFunction0 = null;
        Function<Object, Object> sbByteFunction0 = null;
        Predicate<Object> strLatin1Function0 = null;
        ToLongFunction<Object> bufferAddrFunction0 = null;
        Consumer<Consumer<String>> signalShutdownConsumer0 = null;
        Function<String, ExecutorService> virtualExecutorFunction0 = null;

        if (!"executable".equals(System.getProperty("org.graalvm.nativeimage.kind"))) { //not native-image
            try {
                final ClassLoader loader = Thread.currentThread().getContextClassLoader();
                { //virtualExecutorFunction
                    Class<Function<String, ExecutorService>> virtualClazz1 = null;
                    try {
                        virtualClazz1 = (Class) loader.loadClass("org.redkale.util.AnonymousVirtualExecutor");
                    } catch (Throwable t) {
                    }
                    if (virtualClazz1 == null) {
                        byte[] classBytes = hexToBin(functionVirtualExecutorBinary);
                        try {
                            virtualClazz1 = (Class<Function<String, ExecutorService>>) new ClassLoader(loader) {
                                public final Class<?> loadClass(String name, byte[] b) {
                                    return defineClass(name, b, 0, b.length);
                                }
                            }.loadClass("org.redkale.util.AnonymousVirtualExecutor", classBytes);
                            RedkaleClassLoader.putDynClass(virtualClazz1.getName(), classBytes, virtualClazz1);
                            RedkaleClassLoader.putReflectionDeclaredConstructors(virtualClazz1, virtualClazz1.getName());
                            virtualExecutorFunction0 = virtualClazz1.getConstructor().newInstance();
                        } catch (Throwable t) {
                        }
                    }
                }
                { //unsafe
                    Field f = String.class.getDeclaredField("value");
                    final Class unsafeClass = loader.loadClass("sun.misc.Unsafe");
                    final Field safeField = unsafeClass.getDeclaredField("theUnsafe");
                    RedkaleClassLoader.putReflectionField("sun.misc.Unsafe", safeField);
                    safeField.setAccessible(true);
                    final Object usafe = safeField.get(null);

                    Class<Unsafe> unsafeClazz1 = null;
                    try {
                        unsafeClazz1 = (Class) loader.loadClass("org.redkale.util.AnonymousUnsafe");
                    } catch (Throwable t) {
                    }
                    if (unsafeClazz1 == null) {
                        byte[] classBytes = hexToBin(funcAnonymousUnsafeBinary);
                        unsafeClazz1 = (Class<Unsafe>) new ClassLoader(loader) {
                            public final Class<?> loadClass(String name, byte[] b) {
                                return defineClass(name, b, 0, b.length);
                            }
                        }.loadClass("org.redkale.util.AnonymousUnsafe", classBytes);
                        RedkaleClassLoader.putDynClass(unsafeClazz1.getName(), classBytes, unsafeClazz1);
                    }
                    RedkaleClassLoader.putReflectionDeclaredConstructors(unsafeClazz1, unsafeClazz1.getName(), Object.class);
                    unsafe0 = unsafeClazz1.getConstructor(Object.class).newInstance(usafe);

                    final Unsafe unsafe = unsafe0;
                    final long fd1 = unsafe0.objectFieldOffset(f);
                    final long fd2 = unsafe0.objectFieldOffset(StringBuilder.class.getSuperclass().getDeclaredField("value"));
                    final long fd3 = unsafe0.objectFieldOffset(String.class.getDeclaredField("coder"));
                    final long fd4 = unsafe0.objectFieldOffset(Buffer.class.getDeclaredField("address"));

                    strByteFunction0 = (Object t) -> unsafe.getObject(t, fd1);
                    sbByteFunction0 = (Object t) -> unsafe.getObject(t, fd2);
                    strLatin1Function0 = (Object t) -> unsafe.getByte(t, fd3) == 0; //LATIN1:0  UTF16:1
                    bufferAddrFunction0 = (Object t) -> unsafe.getLong(t, fd4);
                }
                { //signalShutdown
                    Class<Consumer<Consumer<String>>> shutdownClazz1 = null;
                    try {
                        shutdownClazz1 = (Class) loader.loadClass("org.redkale.util.SignalShutDown");
                    } catch (Throwable t) {
                    }
                    if (shutdownClazz1 == null) {
                        byte[] classBytes = hexToBin(consumerSignalShutdownBinary);
                        shutdownClazz1 = (Class<Consumer<Consumer<String>>>) new ClassLoader(loader) {
                            public final Class<?> loadClass(String name, byte[] b) {
                                return defineClass(name, b, 0, b.length);
                            }
                        }.loadClass("org.redkale.util.SignalShutDown", classBytes);
                        RedkaleClassLoader.putDynClass(shutdownClazz1.getName(), classBytes, shutdownClazz1);
                        RedkaleClassLoader.putReflectionDeclaredConstructors(shutdownClazz1, shutdownClazz1.getName());
                        signalShutdownConsumer0 = shutdownClazz1.getConstructor().newInstance();
                    }
                }
            } catch (Throwable e) { //不会发生
                e.printStackTrace();
            }

        }
        unsafeInstance = unsafe0;
        strCharFunction = strCharFunction0;
        sbCharFunction = sbCharFunction0;
        strByteFunction = strByteFunction0;
        sbByteFunction = sbByteFunction0;
        strLatin1Function = strLatin1Function0;
        bufferAddrFunction = bufferAddrFunction0;
        signalShutdownConsumer = signalShutdownConsumer0;
        virtualExecutorFunction = virtualExecutorFunction0;

//        try {
//            DEFAULTSSL_CONTEXT = javax.net.ssl.SSLContext.getInstance("SSL");
//            DEFAULTSSL_CONTEXT.init(null, new javax.net.ssl.TrustManager[]{new javax.net.ssl.X509TrustManager() {
//                @Override
//                public java.security.cert.X509Certificate[] getAcceptedIssuers() {
//                    return null;
//                }
//
//                @Override
//                public void checkServerTrusted(java.security.cert.X509Certificate[] certs, String authType) throws java.security.cert.CertificateException {
//                }
//
//                @Override
//                public void checkClientTrusted(java.security.cert.X509Certificate[] certs, String authType) throws java.security.cert.CertificateException {
//                }
//            }}, null);
//        } catch (Exception e) {
//            throw new RedkaleException(e); //不会发生
//        }
    }

    private Utility() {
    }

    public static Unsafe unsafe() {
        return unsafeInstance;
    }

    public static int cpus() {
        return cpus;
    }

    public static Function<String, ExecutorService> virtualExecutorFunction() {
        return virtualExecutorFunction;
    }

    public static Consumer<Consumer<String>> signalShutdownConsumer() {
        return signalShutdownConsumer;
    }

    public static IntFunction<Serializable[]> serialArrayFunc() {
        return serialArrayFunc;
    }

    public static IntFunction<CompletableFuture[]> futureArrayFunc() {
        return futureArrayFunc;
    }

    public static void sleep(long millis) {
        try {
            Thread.sleep(millis);
        } catch (Exception e) {
        }
    }

    public static boolean isAbstractOrInterface(Class clazz) {
        return clazz.isInterface() || Modifier.isAbstract(clazz.getModifiers());
    }

    /**
     * @param value from which next positive power of two will be found.
     *
     * @return the next positive power of 2, this value if it is a power of 2. Negative values are mapped to 1.
     * @throws IllegalArgumentException is value is more than MAX_POW2 or less than 0
     */
    public static int roundToPowerOfTwo(final int value) {
        if (value > MAX_POW2) {
            throw new IllegalArgumentException("There is no larger power of 2 int for value:" + value + " since it exceeds 2^31.");
        }
        if (value < 0) {
            throw new IllegalArgumentException("Given value:" + value + ". Expecting value >= 0.");
        }
        return 1 << (32 - Integer.numberOfLeadingZeros(value - 1));
    }

    public static boolean isRecordGetter(Method method) {
        return isRecordGetter(method.getDeclaringClass(), method);
    }

    public static boolean isRecordGetter(Class clazz, Method method) {
        if (JAVA_RECORD_CLASS == null) {
            return false;
        }
        if (method.getReturnType() == void.class) {
            return false;
        }
        if (method.getParameterCount() != 0) {
            return false;
        }
        if (method.getName().equals("getClass")) {
            return false;
        }
        Class clz = (clazz == null ? method.getDeclaringClass() : clazz);
        if (!JAVA_RECORD_CLASS.isAssignableFrom(clz)) {
            return false;
        }
        try {
            return clz.getDeclaredField(method.getName()).getType() == method.getReturnType();
        } catch (Throwable t) {
            return false;
        }
    }

    public static <T> CompletableFuture<T> orTimeout(CompletableFuture future, Duration timeout) {
        return future.orTimeout(timeout.toMillis(), TimeUnit.MILLISECONDS);
    }

    public static <T> CompletableFuture<T> completeOnTimeout(CompletableFuture future, T value, Duration timeout) {
        return future.completeOnTimeout(value, timeout.toMillis(), TimeUnit.MILLISECONDS);
    }

    public static <T> CompletableFuture<T> orTimeout(CompletableFuture future, long timeout, TimeUnit unit) {
        return future.orTimeout(timeout, unit);
    }

    public static <T> CompletableFuture<T> completeOnTimeout(CompletableFuture future, T value, long timeout, TimeUnit unit) {
        return future.completeOnTimeout(value, timeout, unit);
    }

    public static <T> CompletableFuture<T[]> allOfFutures(List<CompletableFuture<T>> list, IntFunction<T[]> func) {
        CompletableFuture<T>[] futures = list.toArray(futureArrayFunc);
        return CompletableFuture.allOf(futures).thenApply(v -> {
            int size = futures.length;
            T[] array = func.apply(size);
            for (int i = 0; i < size; i++) {
                array[i] = futures[i].join();
            }
            return array;
        });
    }

    public static <T> CompletableFuture<T[]> allOfFutures(Stream<CompletableFuture<T>> stream, IntFunction<T[]> func) {
        CompletableFuture<T>[] futures = stream.toArray(futureArrayFunc);
        return CompletableFuture.allOf(futures).thenApply(v -> {
            int size = futures.length;
            T[] array = func.apply(size);
            for (int i = 0; i < size; i++) {
                array[i] = futures[i].join();
            }
            return array;
        });
    }

    public static <T> CompletableFuture<T[]> allOfFutures(CompletableFuture<T>[] futures, IntFunction<T[]> func) {
        return CompletableFuture.allOf(futures).thenApply(v -> {
            int size = futures.length;
            T[] array = func.apply(size);
            for (int i = 0; i < size; i++) {
                array[i] = futures[i].join();
            }
            return array;
        });
    }

    public static <T> CompletableFuture<T[]> allOfFutures(List<CompletableFuture<T>> list, IntFunction<T[]> func, BiConsumer<Integer, T> consumer) {
        CompletableFuture<T>[] futures = list.toArray(futureArrayFunc);
        return CompletableFuture.allOf(futures).thenApply(v -> {
            int size = futures.length;
            T[] array = func.apply(size);
            for (int i = 0; i < size; i++) {
                T val = futures[i].join();
                consumer.accept(i, val);
                array[i] = val;
            }
            return array;
        });
    }

    public static <T> CompletableFuture<T[]> allOfFutures(Stream<CompletableFuture<T>> stream, IntFunction<T[]> func, BiConsumer<Integer, T> consumer) {
        CompletableFuture<T>[] futures = stream.toArray(futureArrayFunc);
        return CompletableFuture.allOf(futures).thenApply(v -> {
            int size = futures.length;
            T[] array = func.apply(size);
            for (int i = 0; i < size; i++) {
                T val = futures[i].join();
                consumer.accept(i, val);
                array[i] = val;
            }
            return array;
        });
    }

    public static <T> CompletableFuture<T[]> allOfFutures(CompletableFuture<T>[] futures, IntFunction<T[]> func, BiConsumer<Integer, T> consumer) {
        return CompletableFuture.allOf(futures).thenApply(v -> {
            int size = futures.length;
            T[] array = func.apply(size);
            for (int i = 0; i < size; i++) {
                T val = futures[i].join();
                consumer.accept(i, val);
                array[i] = val;
            }
            return array;
        });
    }

    public static <T> CompletableFuture<List<T>> allOfFutures(List<CompletableFuture<T>> list) {
        CompletableFuture<T>[] futures = list.toArray(futureArrayFunc);
        return CompletableFuture.allOf(futures).thenApply(v -> {
            int size = futures.length;
            List<T> rs = new ArrayList<>(size);
            for (int i = 0; i < size; i++) {
                rs.add(futures[i].join());
            }
            return rs;
        });
    }

    public static <T> CompletableFuture<List<T>> allOfFutures(Stream<CompletableFuture<T>> stream) {
        CompletableFuture<T>[] futures = stream.toArray(futureArrayFunc);
        return CompletableFuture.allOf(futures).thenApply(v -> {
            int size = futures.length;
            List<T> rs = new ArrayList<>(size);
            for (int i = 0; i < size; i++) {
                rs.add(futures[i].join());
            }
            return rs;
        });
    }

    public static <T> CompletableFuture<List<T>> allOfFutures(CompletableFuture<T>[] futures) {
        return CompletableFuture.allOf(futures).thenApply(v -> {
            int size = futures.length;
            List<T> rs = new ArrayList<>(size);
            for (int i = 0; i < size; i++) {
                rs.add(futures[i].join());
            }
            return rs;
        });
    }

    public static <T> CompletableFuture<List<T>> allOfFutures(List<CompletableFuture<T>> list, BiConsumer<Integer, T> consumer) {
        CompletableFuture<T>[] futures = list.toArray(futureArrayFunc);
        return CompletableFuture.allOf(futures).thenApply(v -> {
            int size = futures.length;
            List<T> rs = new ArrayList<>(size);
            for (int i = 0; i < size; i++) {
                T val = futures[i].join();
                consumer.accept(i, val);
                rs.add(val);
            }
            return rs;
        });
    }

    public static <T> CompletableFuture<List<T>> allOfFutures(Stream<CompletableFuture<T>> stream, BiConsumer<Integer, T> consumer) {
        CompletableFuture<T>[] futures = stream.toArray(futureArrayFunc);
        return CompletableFuture.allOf(futures).thenApply(v -> {
            int size = futures.length;
            List<T> rs = new ArrayList<>(size);
            for (int i = 0; i < size; i++) {
                T val = futures[i].join();
                consumer.accept(i, val);
                rs.add(val);
            }
            return rs;
        });
    }

    public static <T> CompletableFuture<List<T>> allOfFutures(CompletableFuture<T>[] futures, BiConsumer<Integer, T> consumer) {
        return CompletableFuture.allOf(futures).thenApply(v -> {
            int size = futures.length;
            List<T> rs = new ArrayList<>(size);
            for (int i = 0; i < size; i++) {
                T val = futures[i].join();
                consumer.accept(i, val);
                rs.add(val);
            }
            return rs;
        });
    }

    /**
     * 是否为数字字符串
     *
     * @param str 字符串
     *
     * @return 是否为数字字符串
     *
     */
    public static boolean isNumeric(String str) {
        if (str == null || str.isEmpty()) {
            return false;
        }
        int size = str.length();
        for (int i = 0; i < size; i++) {
            if (!Character.isDigit(str.charAt(i))) {
                return false;
            }
        }
        return true;
    }

    /**
     * 是否为空白
     *
     * @param str 字符串
     *
     * @return 是否为空白
     *
     */
    public static boolean isBlank(String str) {
        return str == null || str.isEmpty() || str.isBlank();
    }

    /**
     * 是否不为空白
     *
     * @param str 字符串
     *
     * @return 是否不为空白
     *
     */
    public static boolean isNotBlank(String str) {
        return str != null && !str.isEmpty() && !str.isBlank();
    }

    /**
     * 是否为空
     *
     * @param str 字符串
     *
     * @return 是否为空
     *
     */
    public static boolean isEmpty(CharSequence str) {
        return str == null || str.length() == 0;
    }

    /**
     * 是否不为空
     *
     * @param str 字符串
     *
     * @return 是否不为空
     *
     */
    public static boolean isNotEmpty(CharSequence str) {
        return str != null && str.length() > 0;
    }

    /**
     * 是否为空
     *
     * @param map Map
     *
     * @return 是否为空
     *
     */
    public static boolean isEmpty(Map map) {
        return map == null || map.isEmpty();
    }

    /**
     * 是否不为空
     *
     * @param map Map
     *
     * @return 是否不为空
     *
     */
    public static boolean isNotEmpty(Map map) {
        return map != null && !map.isEmpty();
    }

    /**
     * 是否为空
     *
     * @param collection Collection
     *
     * @return 是否为空
     *
     */
    public static boolean isEmpty(Collection collection) {
        return collection == null || collection.isEmpty();
    }

    /**
     * 是否不为空
     *
     * @param collection Collection
     *
     * @return 是否不为空
     *
     */
    public static boolean isNotEmpty(Collection collection) {
        return collection != null && !collection.isEmpty();
    }

    /**
     * 将字符串首字母大写
     *
     * @param str 字符串
     *
     * @return 首字母大写
     */
    public static String firstCharUpperCase(String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }
        if (Character.isUpperCase(str.charAt(0))) {
            return str;
        }
        char[] chs = str.toCharArray();
        chs[0] = Character.toUpperCase(chs[0]);
        return new String(chs);
    }

    /**
     * 将字符串首字母小写
     *
     * @param str 字符串
     *
     * @return 首字母小写
     */
    public static String firstCharLowerCase(String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }
        if (Character.isLowerCase(str.charAt(0))) {
            return str;
        }
        char[] chs = str.toCharArray();
        chs[0] = Character.toLowerCase(chs[0]);
        return new String(chs);
    }

    /**
     * 将多个key:value的字符串键值对组合成一个Map，items长度必须是偶数, 参数个数若是奇数的话，最后一个会被忽略
     * 类似 JDK9中的 Map.of 方法
     *
     * @param items 键值对
     *
     * @return Map
     */
    public static HashMap<String, String> ofMap(String... items) {
        HashMap<String, String> map = new LinkedHashMap<>(Math.max(1, items.length / 2));
        int len = items.length / 2;
        for (int i = 0; i < len; i++) {
            map.put(items[i * 2], items[i * 2 + 1]);
        }
        return map;
    }

    /**
     * 将多个key:value对应值组合成一个Map，items长度必须是偶数, 参数个数若是奇数的话，最后一个会被忽略
     * 类似 JDK9中的 Map.of 方法
     *
     * @param <K>   泛型
     * @param <V>   泛型
     * @param items 键值对
     *
     * @return Map
     */
    public static <K, V> HashMap<K, V> ofMap(Object... items) {
        HashMap<K, V> map = new LinkedHashMap<>(Math.max(1, items.length / 2));
        int len = items.length / 2;
        for (int i = 0; i < len; i++) {
            map.put((K) items[i * 2], (V) items[i * 2 + 1]);
        }
        return map;
    }

    /**
     * 将多个Map合并到第一个Map中
     *
     * @param <K>  泛型
     * @param <V>  泛型
     * @param maps Map
     *
     * @return Map
     */
    public static <K, V> Map<K, V> merge(Map<K, V>... maps) {
        Map<K, V> map = null;
        for (Map<K, V> m : maps) {
            if (map == null) {
                map = m;
            } else if (m != null) {
                map.putAll(m);
            }
        }
        return map;
    }

    /**
     * 将多个元素组合成一个Set
     *
     * @param <T>   泛型
     * @param items 元素
     *
     * @return Set
     */
    public static <T> Set<T> ofSet(T... items) {
        Set<T> set = new LinkedHashSet<>(items.length);
        for (T item : items) set.add(item);
        return set;
    }

    /**
     * 将多个元素组合成一个List <br>
     * 类似 JDK9中的 List.of 方法
     *
     * @param <T>   泛型
     * @param items 元素
     *
     * @return List
     */
    public static <T> List<T> ofList(T... items) {
        List<T> list = new ArrayList<>(items.length);
        for (T item : items) list.add(item);
        return list;
    }

    /**
     * 将多个元素组合成一个Array
     *
     * @param <T>   泛型
     * @param items 元素
     *
     * @return Array
     */
    public static <T> T[] ofArray(T... items) {
        return items;
    }

    /**
     * 裁剪List，使其size不超过limit大小 <br>
     *
     * @param <T>   泛型
     * @param list  集合
     * @param limit 大小
     *
     * @return List
     */
    public static <T> List<T> limit(List<T> list, int limit) {
        if (list == null || list.isEmpty() || list.size() <= limit) {
            return list;
        }
        return list.subList(0, limit);
    }

    /**
     * 获取不带"-"的UUID值
     *
     * @return 不带"-"UUID值
     */
    public static String uuid() {
        return UUID.randomUUID().toString().replace("-", "");
    }

    /**
     * 将一个或多个新元素添加到数组开始，数组中的元素自动后移
     *
     * @param <T>   泛型
     * @param array 原数组
     * @param objs  待追加数据
     *
     * @return 新数组
     */
    public static <T> T[] unshift(final T[] array, final T... objs) {
        if (array == null || array.length == 0) {
            return objs;
        }
        final T[] news = (T[]) Creator.newArray(array.getClass().getComponentType(), array.length + objs.length);
        System.arraycopy(objs, 0, news, 0, objs.length);
        System.arraycopy(array, 0, news, objs.length, array.length);
        return news;
    }

    /**
     * 将一个或多个新元素添加到数组开始，数组中的元素自动后移
     *
     * @param <T>   泛型
     * @param array 原数组
     * @param objs  待追加数据
     *
     * @return 新数组
     */
    public static <T> T[] unshift(final T[] array, final Collection<T> objs) {
        if (objs == null || objs.isEmpty()) {
            return array;
        }
        if (array == null) {
            T one = null;
            for (T t : objs) {
                if (t != null) {
                    one = t;
                }
                break;
            }
            if (one == null) {
                return array;
            }
            T[] news = (T[]) Creator.newArray(one.getClass(), objs.size());
            return objs.toArray(news);
        }
        T[] news = (T[]) Creator.newArray(array.getClass().getComponentType(), array.length + objs.size());
        int index = -1;
        for (T t : objs) {
            news[(++index)] = t;
        }
        System.arraycopy(array, 0, news, objs.size(), array.length);
        return news;
    }

    /**
     * 获取int数组之和, 空数组返回0
     *
     * @param array 数组
     *
     * @return int
     */
    public static int sum(final int... array) {
        return sum(false, array);
    }

    /**
     * 获取int数组之和
     *
     * @param check 是否检测空
     * @param array 数组
     *
     * @return int
     */
    public static int sum(boolean check, final int... array) {
        if (array == null || array.length == 0) {
            if (!check) {
                return 0;
            }
            throw new NullPointerException("array is null or empty");
        }
        int sum = 0;
        for (int i : array) {
            sum += i;
        }
        return sum;
    }

    /**
     * 获取long数组之和, 空数组返回0
     *
     * @param array 数组
     *
     * @return long
     */
    public static long sum(final long... array) {
        return sum(false, array);
    }

    /**
     * 获取long数组之和
     *
     * @param check 是否检测空
     * @param array 数组
     *
     * @return long
     */
    public static long sum(boolean check, final long... array) {
        if (array == null || array.length == 0) {
            if (!check) {
                return 0;
            }
            throw new NullPointerException("array is null or empty");
        }
        long sum = 0L;
        for (long i : array) {
            sum += i;
        }
        return sum;
    }

    /**
     * 获取int数组最大值
     *
     * @param array 数组
     *
     * @return int
     */
    public static int max(final int... array) {
        if (array == null || array.length == 0) {
            throw new NullPointerException("array is null or empty");
        }
        int max = array[0];
        for (int i : array) {
            if (i > max) {
                i = max;
            }
        }
        return max;
    }

    /**
     * 获取long数组最大值
     *
     * @param array 数组
     *
     * @return long
     */
    public static long max(final long... array) {
        if (array == null || array.length == 0) {
            throw new NullPointerException("array is null or empty");
        }
        long max = array[0];
        for (long i : array) {
            if (i > max) {
                i = max;
            }
        }
        return max;
    }

    /**
     * 获取int数组最小值
     *
     * @param array 数组
     *
     * @return int
     */
    public static long min(final int... array) {
        if (array == null || array.length == 0) {
            throw new NullPointerException("array is null or empty");
        }
        int min = array[0];
        for (int i : array) {
            if (i < min) {
                i = min;
            }
        }
        return min;
    }

    /**
     * 获取long数组最小值
     *
     * @param array 数组
     *
     * @return long
     */
    public static long min(final long... array) {
        if (array == null || array.length == 0) {
            throw new NullPointerException("array is null or empty");
        }
        long min = array[0];
        for (long i : array) {
            if (i < min) {
                i = min;
            }
        }
        return min;
    }

    /**
     * 将char数组用分隔符拼接成字符串
     *
     * @param array     数组
     * @param delimiter 分隔符
     *
     * @return String
     */
    public static String joining(final char[] array, final String delimiter) {
        if (array == null || array.length == 0) {
            return "";
        }
        StringBuilder sb = new StringBuilder();
        for (char i : array) {
            if (sb.length() > 0) {
                sb.append(delimiter);
            }
            sb.append(i);
        }
        return sb.toString();
    }

    /**
     * 将int数组用分隔符拼接成字符串
     *
     * @param array     数组
     * @param delimiter 分隔符
     *
     * @return String
     */
    public static String joining(final int[] array, final String delimiter) {
        if (array == null || array.length == 0) {
            return "";
        }
        StringBuilder sb = new StringBuilder();
        for (int i : array) {
            if (sb.length() > 0) {
                sb.append(delimiter);
            }
            sb.append(i);
        }
        return sb.toString();
    }

    /**
     * 将long数组用分隔符拼接成字符串
     *
     * @param array     数组
     * @param delimiter 分隔符
     *
     * @return String
     */
    public static String joining(final long[] array, final String delimiter) {
        if (array == null || array.length == 0) {
            return "";
        }
        StringBuilder sb = new StringBuilder();
        for (long i : array) {
            if (sb.length() > 0) {
                sb.append(delimiter);
            }
            sb.append(i);
        }
        return sb.toString();
    }

    /**
     * 将对象数组用分隔符拼接成字符串
     *
     * @param <T>       泛型
     * @param array     数组
     * @param delimiter 分隔符
     *
     * @return String
     */
    public static <T> String joining(final T[] array, final String delimiter) {
        if (array == null || array.length == 0) {
            return "";
        }
        StringBuilder sb = new StringBuilder();
        for (T i : array) {
            if (sb.length() > 0) {
                sb.append(delimiter);
            }
            sb.append(i);
        }
        return sb.toString();
    }

    /**
     * 将对象集合用分隔符拼接成字符串
     *
     * @param <T>       泛型
     * @param stream    集合
     * @param delimiter 分隔符
     *
     * @return String
     */
    public static <T> String joining(final Stream<T> stream, final String delimiter) {
        if (stream == null) {
            return "";
        }
        StringBuilder sb = new StringBuilder();
        stream.forEach(i -> {
            if (sb.length() > 0) {
                sb.append(delimiter);
            }
            sb.append(i);
        });
        return sb.toString();
    }

    /**
     * 将对象数组用分隔符拼接成字符串
     *
     * @param <T>       泛型
     * @param array     数组
     * @param delimiter 分隔符
     *
     * @return String
     */
    public static <T> String joining(final String[] array, final char delimiter) {
        if (array == null || array.length == 0) {
            return "";
        }
        StringBuilder sb = new StringBuilder();
        for (String i : array) {
            if (sb.length() > 0) {
                sb.append(delimiter);
            }
            sb.append(i);
        }
        return sb.toString();
    }

    /**
     * 将对象数组用分隔符拼接成字符串
     *
     * @param <T>       泛型
     * @param array     数组
     * @param delimiter 分隔符
     *
     * @return String
     */
    public static <T> String joiningHex(final byte[] array, final char delimiter) {
        if (array == null || array.length == 0) {
            return "";
        }
        StringBuilder sb = new StringBuilder();
        for (byte i : array) {
            if (sb.length() > 0) {
                sb.append(delimiter);
            }
            String s = Integer.toHexString(i & 0xff);
            sb.append(s.length() > 1 ? "0x" : "0x0").append(s);
        }
        return sb.toString();
    }

    /**
     * 将对象数组用分隔符拼接成字符串
     *
     * @param <T>       泛型
     * @param array     数组
     * @param offset    偏移量
     * @param length    长度
     * @param delimiter 分隔符
     *
     * @return String
     */
    public static <T> String joiningHex(final byte[] array, int offset, int length, final char delimiter) {
        if (array == null || array.length == 0) {
            return "";
        }
        StringBuilder sb = new StringBuilder();
        int len = offset + length;
        for (int i = offset; i < len; i++) {
            if (sb.length() > 0) {
                sb.append(delimiter);
            }
            String s = Integer.toHexString(array[i] & 0xff);
            sb.append(s.length() > 1 ? "0x" : "0x0").append(s);
        }
        return sb.toString();
    }

    /**
     * 将一个或多个byte新元素添加到byte数组结尾
     *
     * @param array 原数组
     * @param objs  待追加数据
     *
     * @return 新数组
     */
    public static byte[] append(final byte[] array, final byte... objs) {
        if (array == null || array.length == 0) {
            return objs;
        }
        if (objs == null || objs.length == 0) {
            return array;
        }
        final byte[] news = new byte[array.length + objs.length];
        System.arraycopy(array, 0, news, 0, array.length);
        System.arraycopy(objs, 0, news, array.length, objs.length);
        return news;
    }

    /**
     * 将一个或多个byte新元素添加到byte数组结尾
     *
     * @param array  原数组
     * @param objs   待追加数据
     * @param offset 待追加数据偏移量
     * @param length 待追加数据的长度
     *
     * @return 新数组
     */
    public static byte[] append(final byte[] array, final byte[] objs, int offset, int length) {
        if (array == null || array.length == 0) {
            if (objs != null && offset == 0 && objs.length == length) {
                return objs;
            }
            final byte[] news = new byte[length];
            System.arraycopy(objs, 0, news, 0, length);
            return news;
        }
        if (objs == null || length == 0) {
            return array;
        }
        final byte[] news = new byte[array.length + length];
        System.arraycopy(array, 0, news, 0, array.length);
        System.arraycopy(objs, offset, news, array.length, length);
        return news;
    }

    /**
     * 将一个或多个short新元素添加到short数组结尾
     *
     * @param array 原数组
     * @param objs  待追加数据
     *
     * @return 新数组
     */
    public static short[] append(final short[] array, final short... objs) {
        if (array == null || array.length == 0) {
            return objs;
        }
        if (objs == null || objs.length == 0) {
            return array;
        }
        final short[] news = new short[array.length + objs.length];
        System.arraycopy(array, 0, news, 0, array.length);
        System.arraycopy(objs, 0, news, array.length, objs.length);
        return news;
    }

    /**
     * 将一个或多个char新元素添加到char数组结尾
     *
     * @param array 原数组
     * @param objs  待追加数据
     *
     * @return 新数组
     */
    public static char[] append(final char[] array, final char... objs) {
        if (array == null || array.length == 0) {
            return objs;
        }
        if (objs == null || objs.length == 0) {
            return array;
        }
        final char[] news = new char[array.length + objs.length];
        System.arraycopy(array, 0, news, 0, array.length);
        System.arraycopy(objs, 0, news, array.length, objs.length);
        return news;
    }

    /**
     * 将一个或多个int新元素添加到int数组结尾
     *
     * @param array 原数组
     * @param objs  待追加数据
     *
     * @return 新数组
     */
    public static int[] append(final int[] array, final int... objs) {
        if (array == null || array.length == 0) {
            return objs;
        }
        if (objs == null || objs.length == 0) {
            return array;
        }
        final int[] news = new int[array.length + objs.length];
        System.arraycopy(array, 0, news, 0, array.length);
        System.arraycopy(objs, 0, news, array.length, objs.length);
        return news;
    }

    /**
     * 将一个或多个long新元素添加到long数组结尾
     *
     * @param array 原数组
     * @param objs  待追加数据
     *
     * @return 新数组
     */
    public static long[] append(final long[] array, final long... objs) {
        if (array == null || array.length == 0) {
            return objs;
        }
        if (objs == null || objs.length == 0) {
            return array;
        }
        final long[] news = new long[array.length + objs.length];
        System.arraycopy(array, 0, news, 0, array.length);
        System.arraycopy(objs, 0, news, array.length, objs.length);
        return news;
    }

    /**
     * 将一个或多个新元素添加到数组结尾
     *
     * @param array 原数组
     * @param objs  待追加数据
     *
     * @return 新数组
     */
    public static String[] append(final String[] array, final String... objs) {
        if (array == null || array.length == 0) {
            return objs;
        }
        if (objs == null || objs.length == 0) {
            return array;
        }
        final String[] news = new String[array.length + objs.length];
        System.arraycopy(array, 0, news, 0, array.length);
        System.arraycopy(objs, 0, news, array.length, objs.length);
        return news;
    }

    /**
     * 将一个或多个新元素添加到数组结尾
     *
     * @param one  单个对象
     * @param objs 待追加数据
     *
     * @return 新数组
     */
    public static String[] append(final String one, final String... objs) {
        if (one == null) {
            return objs;
        }
        final String[] news = new String[1 + objs.length];
        news[0] = one;
        System.arraycopy(objs, 0, news, 1, objs.length);
        return news;
    }

    /**
     * 将一个或多个新元素添加到数组结尾
     *
     * @param one  单个对象
     * @param two  单个对象
     * @param objs 待追加数据
     *
     * @return 新数组
     */
    public static String[] append(final String one, String two, final String... objs) {
        final String[] news = new String[2 + objs.length];
        news[0] = one;
        news[1] = two;
        System.arraycopy(objs, 0, news, 2, objs.length);
        return news;
    }

    /**
     * 将一个或多个新元素添加到数组结尾
     *
     * @param <T>   泛型
     * @param array 原数组
     * @param objs  待追加数据
     *
     * @return 新数组
     */
    public static <T> T[] append(final T[] array, final T... objs) {
        if (array == null || array.length == 0) {
            return objs;
        }
        if (objs == null || objs.length == 0) {
            return array;
        }
        final T[] news = (T[]) Creator.newArray(array.getClass().getComponentType(), array.length + objs.length);
        System.arraycopy(array, 0, news, 0, array.length);
        System.arraycopy(objs, 0, news, array.length, objs.length);
        return news;
    }

    /**
     * 将一个或多个新元素添加到数组结尾
     *
     * @param <T>  泛型
     * @param one  单个对象
     * @param objs 待追加数据
     *
     * @return 新数组
     */
    public static <T> T[] append(final T one, final T... objs) {
        if (one == null) {
            return objs;
        }
        final T[] news = (T[]) Creator.newArray(one.getClass().getComponentType(), 1 + objs.length);
        news[0] = one;
        System.arraycopy(objs, 0, news, 1, objs.length);
        return news;
    }

    /**
     * 将一个或多个新元素添加到数组结尾
     *
     * @param <T>  泛型
     * @param one  单个对象
     * @param two  单个对象
     * @param objs 待追加数据
     *
     * @return 新数组
     */
    public static <T> T[] append(final T one, T two, final T... objs) {
        final T[] news = (T[]) Creator.newArray(one.getClass().getComponentType(), 2 + objs.length);
        news[0] = one;
        news[1] = two;
        System.arraycopy(objs, 0, news, 2, objs.length);
        return news;
    }

    /**
     * 将一个或多个新元素添加到数组结尾
     *
     * @param <T>   泛型
     * @param array 原数组
     * @param objs  待追加数据
     *
     * @return 新数组
     */
    public static <T> Object[][] append(final Object[][] array, final Object[]... objs) {
        if (array == null || array.length == 0) {
            return objs;
        }
        if (objs == null || objs.length == 0) {
            return array;
        }
        final Object[][] news = new Object[array.length + objs.length][];
        System.arraycopy(array, 0, news, 0, array.length);
        System.arraycopy(objs, 0, news, array.length, objs.length);
        return news;
    }

    /**
     * 将一个或多个新元素添加到数组结尾
     *
     * @param <T>   泛型
     * @param array 原数组
     * @param objs  待追加数据
     *
     * @return 新数组
     */
    public static <T> T[] append(final T[] array, final Collection<T> objs) {
        if (objs == null || objs.isEmpty()) {
            return array;
        }
        if (array == null) {
            T one = null;
            for (T t : objs) {
                if (t != null) {
                    one = t;
                }
                break;
            }
            if (one == null) {
                return array;
            }
            T[] news = (T[]) Creator.newArray(one.getClass(), objs.size());
            return objs.toArray(news);
        }
        T[] news = (T[]) Creator.newArray(array.getClass().getComponentType(), array.length + objs.size());
        System.arraycopy(array, 0, news, 0, array.length);
        int index = -1;
        for (T t : objs) {
            news[array.length + (++index)] = t;
        }
        return news;
    }

    /**
     * 将int数组倒序
     *
     * @param array 原数组
     *
     * @return 新数组
     */
    public static int[] reverseSort(final int[] array) {
        if (array == null || array.length == 0) {
            return array;
        }
        return Arrays.stream(array).boxed().sorted(Collections.reverseOrder()).mapToInt(x -> x).toArray();
    }

    /**
     * 将long数组倒序
     *
     * @param array 原数组
     *
     * @return 新数组
     */
    public static long[] reverseSort(final long[] array) {
        if (array == null || array.length == 0) {
            return array;
        }
        return Arrays.stream(array).boxed().sorted(Collections.reverseOrder()).mapToLong(x -> x).toArray();
    }

    /**
     * 将元素从数组中删除
     *
     * @param <T>   泛型
     * @param array 原数组
     * @param item  元素
     *
     * @return 新数组
     */
    public static <T> T[] remove(final T[] array, final T item) {
        return remove(array, (i) -> Objects.equals(i, item));
    }

    /**
     * 将符合条件的元素从数组中删除
     *
     * @param <T>    泛型
     * @param array  原数组
     * @param filter Predicate
     *
     * @return 新数组
     */
    public static <T> T[] remove(final T[] array, final Predicate filter) {
        if (array == null || array.length == 0 || filter == null) {
            return array;
        }
        final T[] news = (T[]) Creator.newArray(array.getClass().getComponentType(), array.length);
        int index = 0;
        for (int i = 0; i < news.length; i++) {
            if (!filter.test(array[i])) {
                news[index++] = array[i];
            }
        }
        if (index == array.length) {
            return array;
        }
        final T[] rs = (T[]) Creator.newArray(array.getClass().getComponentType(), index);
        System.arraycopy(news, 0, rs, 0, index);
        return rs;
    }

    /**
     * 将符合条件的元素从数组中删除
     *
     * @param array 原数组
     * @param item  元素
     *
     * @return 新数组
     */
    public static String[] remove(final String[] array, final String item) {
        if (array == null || array.length == 0) {
            return array;
        }
        final String[] news = new String[array.length];
        int index = 0;
        for (int i = 0; i < news.length; i++) {
            if (item != null && !item.equals(array[i])) {
                news[index++] = array[i];
            } else if (item == null && array[i] != null) {
                news[index++] = array[i];
            }
        }
        if (index == array.length) {
            return array;
        }
        final String[] rs = new String[index];
        System.arraycopy(news, 0, rs, 0, index);
        return rs;
    }

    /**
     * 将指定的long元素从数组中删除, 相同的元素会根据items里重复次数来执行删除 <br>
     * 例如: <br>
     * remove(new short[]{1, 1, 1, 2, 2, 3, 3, 3}, false, 1, 1, 2, 3, 3) = [1,2,3]<br>
     *
     * @param array 原数组
     * @param items short[]
     *
     * @return 新数组
     */
    public static short[] removeMatch(final short[] array, final short... items) {
        return remove(array, false, items);
    }

    /**
     * 将指定的int元素从数组中删除, repeat=true时相同的元素会根据items里重复次数来执行删除 <br>
     * 例如: <br>
     * remove(new short[]{1, 1, 1, 2, 2, 3, 3, 3}, true, 1, 1, 2, 3, 3) = [] <br>
     * remove(new short[]{1, 1, 1, 2, 2, 3, 3, 3}, false, 1, 1, 2, 3, 3) = [1,2,3]
     *
     * @param array  原数组
     * @param repeat 是否重复删除相同的元素
     * @param items  short[]
     *
     * @return 新数组
     */
    public static short[] remove(final short[] array, boolean repeat, final short... items) {
        if (array == null || array.length == 0 || items == null || items.length == 0) {
            return array;
        }
        final short[] news = new short[array.length];
        short[] subs = items;
        int index = 0;
        for (int i = 0; i < news.length; i++) {
            if (subs.length > 0 && contains(subs, array[i])) {
                if (!repeat) {
                    short[] newsubs = new short[subs.length - 1];
                    int k = 0;
                    boolean done = false;
                    for (short v : subs) {
                        if (done) {
                            newsubs[k++] = v;
                        } else if (v == array[i]) {
                            done = true;
                        } else {
                            newsubs[k++] = v;
                        }
                    }
                    subs = newsubs;
                }
            } else {
                news[index++] = array[i];
            }
        }
        if (index == array.length) {
            return array;
        }
        final short[] rs = new short[index];
        System.arraycopy(news, 0, rs, 0, index);
        return rs;
    }

    /**
     * 将指定的long元素从数组中删除, 相同的元素会根据items里重复次数来执行删除 <br>
     * 例如: <br>
     * remove(new int[]{1, 1, 1, 2, 2, 3, 3, 3}, false, 1, 1, 2, 3, 3) = [1,2,3]<br>
     *
     * @param array 原数组
     * @param items int[]
     *
     * @return 新数组
     */
    public static int[] removeMatch(final int[] array, final int... items) {
        return remove(array, false, items);
    }

    /**
     * 将指定的int元素从数组中删除, repeat=false时相同的元素会根据items里重复次数来执行删除 <br>
     * 例如: <br>
     * remove(new int[]{1, 1, 1, 2, 2, 3, 3, 3}, true, 1, 1, 2, 3, 3) = [] <br>
     * remove(new int[]{1, 1, 1, 2, 2, 3, 3, 3}, false, 1, 1, 2, 3, 3) = [1,2,3]
     *
     * @param array  原数组
     * @param repeat 是否重复删除相同的元素
     * @param items  int[]
     *
     * @return 新数组
     */
    public static int[] remove(final int[] array, boolean repeat, final int... items) {
        if (array == null || array.length == 0 || items == null || items.length == 0) {
            return array;
        }
        final int[] news = new int[array.length];
        int[] subs = items;
        int index = 0;
        for (int i = 0; i < news.length; i++) {
            if (subs.length > 0 && contains(subs, array[i])) {
                if (!repeat) {
                    int[] newsubs = new int[subs.length - 1];
                    int k = 0;
                    boolean done = false;
                    for (int v : subs) {
                        if (done) {
                            newsubs[k++] = v;
                        } else if (v == array[i]) {
                            done = true;
                        } else {
                            newsubs[k++] = v;
                        }
                    }
                    subs = newsubs;
                }
            } else {
                news[index++] = array[i];
            }
        }
        if (index == array.length) {
            return array;
        }
        final int[] rs = new int[index];
        System.arraycopy(news, 0, rs, 0, index);
        return rs;
    }

    /**
     * 将指定的long元素从数组中删除, 相同的元素会根据items里重复次数来执行删除 <br>
     * 例如: <br>
     * remove(new long[]{1, 1, 1, 2, 2, 3, 3, 3}, false, 1, 1, 2, 3, 3) = [1,2,3]<br>
     *
     * @param array 原数组
     * @param items long[]
     *
     * @return 新数组
     */
    public static long[] removeMatch(final long[] array, final long... items) {
        return remove(array, false, items);
    }

    /**
     * 将指定的long元素从数组中删除, repeat=false时相同的元素会根据items里重复次数来执行删除 <br>
     * 例如: <br>
     * remove(new long[]{1, 1, 1, 2, 2, 3, 3, 3}, true, 1, 1, 2, 3, 3) = [] <br>
     * remove(new long[]{1, 1, 1, 2, 2, 3, 3, 3}, false, 1, 1, 2, 3, 3) = [1,2,3]<br>
     *
     * @param array  原数组
     * @param repeat 是否重复删除相同的元素
     * @param items  long[]
     *
     * @return 新数组
     */
    public static long[] remove(final long[] array, boolean repeat, final long... items) {
        if (array == null || array.length == 0 || items == null || items.length == 0) {
            return array;
        }
        final long[] news = new long[array.length];
        long[] subs = items;
        int index = 0;
        for (int i = 0; i < news.length; i++) {
            if (subs.length > 0 && contains(subs, array[i])) {
                if (!repeat) {
                    long[] newsubs = new long[subs.length - 1];
                    int k = 0;
                    boolean done = false;
                    for (long v : subs) {
                        if (done) {
                            newsubs[k++] = v;
                        } else if (v == array[i]) {
                            done = true;
                        } else {
                            newsubs[k++] = v;
                        }
                    }
                    subs = newsubs;
                }
            } else {
                news[index++] = array[i];
            }
        }
        if (index == array.length) {
            return array;
        }
        final long[] rs = new long[index];
        System.arraycopy(news, 0, rs, 0, index);
        return rs;
    }

    /**
     * 将符合条件的元素从集合中删除
     *
     * @param <T>    泛型
     * @param objs   原集合
     * @param filter Predicate
     *
     * @return 新集合
     */
    public static <T> Collection<T> remove(final Collection<T> objs, Predicate filter) {
        if (objs == null || filter == null) {
            return objs;
        }
        List<T> list = new ArrayList<>();
        for (T t : objs) {
            if (filter.test(t)) {
                list.add(t);
            }
        }
        if (!list.isEmpty()) {
            objs.removeAll(list);
        }
        return objs;
    }

    /**
     * 判断字符串是否包含指定的字符，包含返回true
     *
     * @param string 字符串
     * @param values 字符集合
     *
     * @return boolean
     */
    public static boolean contains(String string, char... values) {
        if (string == null) {
            return false;
        }
        for (char ch : Utility.charArray(string)) {
            for (char ch2 : values) {
                if (ch == ch2) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * 比较两集合元素是否一样， 顺序不要求一样
     *
     * @param <T>    泛型
     * @param array1 集合
     * @param array2 集合
     *
     * @return 元素是否完全相同
     */
    public static <T> boolean equalsElement(T[] array1, T[] array2) {
        if (array1 == null && array2 == null) {
            return true;
        }
        if (array1 == null || array2 == null) {
            return false;
        }
        if (array1.length != array2.length) {
            return false;
        }
        return equalsElement(ofList(array1), ofList(array2));
    }

    /**
     * 比较两集合元素是否一样， 顺序不要求一样
     *
     * @param <T>  泛型
     * @param col1 集合
     * @param col2 集合
     *
     * @return 元素是否完全相同
     */
    public static <T> boolean equalsElement(Collection<T> col1, Collection<T> col2) {
        if (col1 == null && col2 == null) {
            return true;
        }
        if (col1 == null || col2 == null) {
            return false;
        }
        if (col1.size() != col2.size()) {
            return false;
        }
        //{1,2,2}, {1,1,2}
        List<T> list = new ArrayList<>(col2);
        for (T item : col1) {
            if (!list.remove(item)) {
                return false;
            }
        }
        return list.isEmpty();
    }

    /**
     * 比较两集合元素是否一样， 顺序不要求一样
     *
     * @param <K>  泛型
     * @param <V>  泛型
     * @param map1 集合
     * @param map2 集合
     *
     * @return 元素是否完全相同
     */
    public static <K, V> boolean equalsElement(Map<K, V> map1, Map<K, V> map2) {
        if (map1 == null && map2 == null) {
            return true;
        }
        if (map1 == null || map2 == null) {
            return false;
        }
        if (map1.size() != map2.size()) {
            return false;
        }
        for (Map.Entry<K, V> en : map1.entrySet()) {
            if (!Objects.equals(en.getValue(), map2.get(en.getKey()))) {
                return false;
            }
        }
        return true;
    }

    /**
     * 判断指定值是否包含指定的数组中，包含返回true
     *
     * @param values 集合
     * @param value  单值
     *
     * @return boolean
     */
    public static boolean contains(char[] values, char value) {
        if (values == null) {
            return false;
        }
        for (char v : values) {
            if (v == value) {
                return true;
            }
        }
        return false;
    }

    /**
     * 判断指定值是否包含指定的数组中，包含返回true
     *
     * @param values 集合
     * @param value  单值
     *
     * @return boolean
     */
    public static boolean contains(short[] values, short value) {
        if (values == null) {
            return false;
        }
        for (short v : values) {
            if (v == value) {
                return true;
            }
        }
        return false;
    }

    /**
     * 判断指定值(不要包含相同的元素)是否包含指定的数组中，包含返回true
     *
     * @param values 集合
     * @param items  多值
     *
     * @return boolean
     */
    public static boolean contains(short[] values, short... items) {
        if (values == null) {
            return false;
        }
        for (short item : items) {
            if (!contains(values, item)) {
                return false;
            }
        }
        return true;
    }

    /**
     * 判断指定值是否包含指定的数组中，包含返回true
     *
     * @param values 集合
     * @param value  单值
     *
     * @return boolean
     */
    public static boolean contains(int[] values, int value) {
        if (values == null) {
            return false;
        }
        for (int v : values) {
            if (v == value) {
                return true;
            }
        }
        return false;
    }

    /**
     * 判断指定值(不要包含相同的元素)是否包含指定的数组中，包含返回true
     *
     * @param values 集合
     * @param items  多值
     *
     * @return boolean
     */
    public static boolean contains(int[] values, int... items) {
        if (values == null) {
            return false;
        }
        for (int item : items) {
            if (!contains(values, item)) {
                return false;
            }
        }
        return true;
    }

    /**
     * 判断指定值是否包含指定的数组中，包含返回true
     *
     * @param values 集合
     * @param value  单值
     *
     * @return boolean
     */
    public static boolean contains(long[] values, long value) {
        if (values == null) {
            return false;
        }
        for (long v : values) {
            if (v == value) {
                return true;
            }
        }
        return false;
    }

    /**
     * 判断指定值(不要包含相同的元素)是否包含指定的数组中，包含返回true
     *
     * @param values 集合
     * @param items  多值
     *
     * @return boolean
     */
    public static boolean contains(long[] values, long... items) {
        if (values == null) {
            return false;
        }
        for (long item : items) {
            if (!contains(values, item)) {
                return false;
            }
        }
        return true;
    }

    /**
     * 判断指定值是否包含指定的数组中，包含返回true
     *
     * @param <T>    泛型
     * @param values 集合
     * @param value  单值
     *
     * @return boolean
     */
    public static <T> boolean contains(T[] values, T value) {
        if (values == null) {
            return false;
        }
        for (T v : values) {
            if (Objects.equals(v, value)) {
                return true;
            }
        }
        return false;
    }

    /**
     * 判断指定值是否包含指定的数组中，包含返回true
     *
     * @param <T>       泛型
     * @param values    集合
     * @param predicate 过滤条件
     *
     * @return boolean
     */
    public static <T> boolean contains(T[] values, Predicate<T> predicate) {
        if (values == null) {
            return false;
        }
        for (T v : values) {
            if (predicate.test(v)) {
                return true;
            }
        }
        return false;
    }

    /**
     * 将指定的short元素是否数组中完全包含，重复元素的次数也要相同 <br>
     * 例如: <br>
     * containsMatch(new short[]{1, 2, 2, 3, 3, 3}, 1, 2, 3, 3) = true <br>
     * containsMatch(new short[]{1, 2, 2, 3, 3, 3}, 1, 1, 2, 3, 3) = false <br>
     *
     * @param array 原数组
     * @param items short[]
     *
     * @return 是否完全包含
     */
    public static boolean containsMatch(final short[] array, final short... items) {
        if (array == null) {
            return false;
        }
        if (items == null || items.length == 0) {
            return true;
        }
        if (array.length == 0 && items.length == 0) {
            return true;
        }
        if (array.length < items.length) {
            return false;
        }

        short[] subs = array;
        for (short item : items) {
            if (!contains(subs, item)) {
                return false;
            }
            short[] newsubs = new short[subs.length - 1];
            int k = 0;
            boolean done = false;
            for (short v : subs) {
                if (done) {
                    newsubs[k++] = v;
                } else if (v == item) {
                    done = true;
                } else {
                    newsubs[k++] = v;
                }
            }
            subs = newsubs;
        }
        return true;
    }

    /**
     * 将指定的int元素是否数组中完全包含，重复元素的次数也要相同 <br>
     * 例如: <br>
     * containsMatch(new int[]{1, 2, 2, 3, 3, 3}, 1, 2, 3, 3) = true <br>
     * containsMatch(new int[]{1, 2, 2, 3, 3, 3}, 1, 1, 2, 3, 3) = false <br>
     *
     * @param array 原数组
     * @param items int[]
     *
     * @return 是否完全包含
     */
    public static boolean containsMatch(final int[] array, final int... items) {
        if (array == null) {
            return false;
        }
        if (items == null || items.length == 0) {
            return true;
        }
        if (array.length == 0 && items.length == 0) {
            return true;
        }
        if (array.length < items.length) {
            return false;
        }

        int[] subs = array;
        for (int item : items) {
            if (!contains(subs, item)) {
                return false;
            }
            int[] newsubs = new int[subs.length - 1];
            int k = 0;
            boolean done = false;
            for (int v : subs) {
                if (done) {
                    newsubs[k++] = v;
                } else if (v == item) {
                    done = true;
                } else {
                    newsubs[k++] = v;
                }
            }
            subs = newsubs;
        }
        return true;
    }

    /**
     * 将指定的long元素是否数组中完全包含，重复元素的次数也要相同 <br>
     * 例如: <br>
     * containsMatch(new long[]{1, 2, 2, 3, 3, 3}, 1, 2, 3, 3) = true <br>
     * containsMatch(new long[]{1, 2, 2, 3, 3, 3}, 1, 1, 2, 3, 3) = false <br>
     *
     * @param array 原数组
     * @param items long[]
     *
     * @return 是否完全包含
     */
    public static boolean containsMatch(final long[] array, final long... items) {
        if (array == null) {
            return false;
        }
        if (items == null || items.length == 0) {
            return true;
        }
        if (array.length == 0 && items.length == 0) {
            return true;
        }
        if (array.length < items.length) {
            return false;
        }

        long[] subs = array;
        for (long item : items) {
            if (!contains(subs, item)) {
                return false;
            }
            long[] newsubs = new long[subs.length - 1];
            int k = 0;
            boolean done = false;
            for (long v : subs) {
                if (done) {
                    newsubs[k++] = v;
                } else if (v == item) {
                    done = true;
                } else {
                    newsubs[k++] = v;
                }
            }
            subs = newsubs;
        }
        return true;
    }

    /**
     * 删除掉字符串数组中包含指定的字符串
     *
     * @param columns 待删除数组
     * @param cols    需排除的字符串
     *
     * @return 新字符串数组
     */
    public static String[] exclude(final String[] columns, final String... cols) {
        if (columns == null || columns.length == 0 || cols == null || cols.length == 0) {
            return columns;
        }
        int count = 0;
        for (String column : columns) {
            boolean flag = false;
            for (String col : cols) {
                if (column != null && column.equals(col)) {
                    flag = true;
                    break;
                }
            }
            if (flag) {
                count++;
            }
        }
        if (count == 0) {
            return columns;
        }
        if (count == columns.length) {
            return new String[0];
        }
        final String[] newcols = new String[columns.length - count];
        count = 0;
        for (String column : columns) {
            boolean flag = false;
            for (String col : cols) {
                if (column != null && column.equals(col)) {
                    flag = true;
                    break;
                }
            }
            if (!flag) {
                newcols[count++] = column;
            }
        }
        return newcols;
    }

    /**
     * 查询指定对象, 没有返回null
     *
     * @param <T>       泛型
     * @param array     数组
     * @param predicate 查找器
     *
     * @return 对象
     */
    public static <T> T find(final T[] array, final Predicate<T> predicate) {
        if (array == null) {
            return null;
        }
        for (T item : array) {
            if (item != null && predicate.test(item)) {
                return item;
            }
        }
        return null;
    }

    /**
     * 查询指定对象, 没有返回null
     *
     * @param <T>       泛型
     * @param array     数组
     * @param predicate 查找器
     *
     * @return 对象
     */
    public static <T> T find(final Collection<T> array, final Predicate<T> predicate) {
        if (array == null) {
            return null;
        }
        for (T item : array) {
            if (item != null && predicate.test(item)) {
                return item;
            }
        }
        return null;
    }

    /**
     * 查询指定对象位置, 没有返回-1
     *
     * @param <T>       泛型
     * @param array     数组
     * @param predicate 查找器
     *
     * @return 位置
     */
    public static <T> int indexOf(final T[] array, final Predicate<T> predicate) {
        if (array == null) {
            return -1;
        }
        int index = -1;
        for (T item : array) {
            ++index;
            if (item != null && predicate.test(item)) {
                return index;
            }
        }
        return -1;
    }

    /**
     * 查询指定对象位置, 没有返回-1
     *
     * @param <T>       泛型
     * @param array     数组
     * @param predicate 查找器
     *
     * @return 位置
     */
    public static <T> int indexOf(final Collection<T> array, final Predicate<T> predicate) {
        if (array == null) {
            return -1;
        }
        int index = -1;
        for (T item : array) {
            ++index;
            if (item != null && predicate.test(item)) {
                return index;
            }
        }
        return -1;
    }

    /**
     * 查询指定值位置, 没有返回-1
     *
     * @param array   数组
     * @param element 指定值
     *
     * @return 位置
     */
    public static int indexOf(final byte[] array, final byte element) {
        if (array == null) {
            return -1;
        }
        for (int i = 0; i < array.length; ++i) {
            if (array[i] == element) {
                return i;
            }
        }
        return -1;
    }

    /**
     * 查询指定值位置, 没有返回-1
     *
     * @param array     数组
     * @param fromIndex 起始位置，从0开始
     * @param element   指定值
     *
     * @return 位置
     */
    public static int indexOf(final byte[] array, int fromIndex, final byte element) {
        if (array == null) {
            return -1;
        }
        for (int i = fromIndex; i < array.length; ++i) {
            if (array[i] == element) {
                return i;
            }
        }
        return -1;
    }

    /**
     * 查询指定值位置, 没有返回-1
     *
     * @param array   数组
     * @param element 指定值
     *
     * @return 位置
     */
    public static int indexOf(final short[] array, final short element) {
        return indexOf(array, 0, element);
    }

    /**
     * 查询指定值位置, 没有返回-1
     *
     * @param array     数组
     * @param fromIndex 起始位置，从0开始
     * @param element   指定值
     *
     * @return 位置
     */
    public static int indexOf(final short[] array, int fromIndex, final short element) {
        if (array == null) {
            return -1;
        }
        for (int i = fromIndex; i < array.length; ++i) {
            if (array[i] == element) {
                return i;
            }
        }
        return -1;
    }

    /**
     * 查询指定值位置, 没有返回-1
     *
     * @param array   数组
     * @param element 指定值
     *
     * @return 位置
     */
    public static int indexOf(final char[] array, final char element) {
        return indexOf(array, 0, element);
    }

    /**
     * 查询指定值位置, 没有返回-1
     *
     * @param array     数组
     * @param fromIndex 起始位置，从0开始
     * @param element   指定值
     *
     * @return 位置
     */
    public static int indexOf(final char[] array, int fromIndex, final char element) {
        if (array == null) {
            return -1;
        }
        for (int i = fromIndex; i < array.length; ++i) {
            if (array[i] == element) {
                return i;
            }
        }
        return -1;
    }

    /**
     * 查询指定值位置, 没有返回-1
     *
     * @param array   数组
     * @param element 指定值
     *
     * @return 位置
     */
    public static int indexOf(final int[] array, final int element) {
        return indexOf(array, 0, element);
    }

    /**
     * 查询指定值位置, 没有返回-1
     *
     * @param array     数组
     * @param fromIndex 起始位置，从0开始
     * @param element   指定值
     *
     * @return 位置
     */
    public static int indexOf(final int[] array, int fromIndex, final int element) {
        if (array == null) {
            return -1;
        }
        for (int i = fromIndex; i < array.length; ++i) {
            if (array[i] == element) {
                return i;
            }
        }
        return -1;
    }

    /**
     * 查询指定值位置, 没有返回-1
     *
     * @param array   数组
     * @param element 指定值
     *
     * @return 位置
     */
    public static int indexOf(final long[] array, final long element) {
        return indexOf(array, 0, element);
    }

    /**
     * 查询指定值位置, 没有返回-1
     *
     * @param array     数组
     * @param fromIndex 起始位置，从0开始
     * @param element   指定值
     *
     * @return 位置
     */
    public static int indexOf(final long[] array, int fromIndex, final long element) {
        if (array == null) {
            return -1;
        }
        for (int i = fromIndex; i < array.length; ++i) {
            if (array[i] == element) {
                return i;
            }
        }
        return -1;
    }

    /**
     * 查询指定值位置, 没有返回-1
     *
     * @param array   数组
     * @param element 指定值
     *
     * @return 位置
     */
    public static int indexOf(final float[] array, final float element) {
        return indexOf(array, 0, element);
    }

    /**
     * 查询指定值位置, 没有返回-1
     *
     * @param array     数组
     * @param fromIndex 起始位置，从0开始
     * @param element   指定值
     *
     * @return 位置
     */
    public static int indexOf(final float[] array, int fromIndex, final float element) {
        if (array == null) {
            return -1;
        }
        for (int i = fromIndex; i < array.length; ++i) {
            if (array[i] == element) {
                return i;
            }
        }
        return -1;
    }

    /**
     * 查询指定值位置, 没有返回-1
     *
     * @param array   数组
     * @param element 指定值
     *
     * @return 位置
     */
    public static int indexOf(final double[] array, final double element) {
        return indexOf(array, 0, element);
    }

    /**
     * 查询指定值位置, 没有返回-1
     *
     * @param array     数组
     * @param fromIndex 起始位置，从0开始
     * @param element   指定值
     *
     * @return 位置
     */
    public static int indexOf(final double[] array, int fromIndex, final double element) {
        if (array == null) {
            return -1;
        }
        for (int i = fromIndex; i < array.length; ++i) {
            if (array[i] == element) {
                return i;
            }
        }
        return -1;
    }

    /**
     * 将buffer的内容转换成字符串, string参数不为空时会追加在buffer内容字符串之前
     *
     * @param string 字符串前缀
     * @param buffer ByteBuffer
     *
     * @return 字符串
     */
    public static String toString(String string, ByteBuffer buffer) {
        if (buffer == null || !buffer.hasRemaining()) {
            return string;
        }
        int pos = buffer.position();
        int limit = buffer.limit();
        byte[] bytes = new byte[buffer.remaining()];
        buffer.get(bytes);
        buffer.position(pos);
        buffer.limit(limit);
        if (string == null) {
            return new String(bytes, UTF_8);
        }
        return string + new String(bytes, UTF_8);
    }

    /**
     * 将buffer的内容转换成字符串并打印到控制台, string参数不为空时会追加在buffer内容字符串之前
     *
     * @param string 字符串前缀
     * @param buffer ByteBuffer
     *
     */
    public static void println(String string, ByteBuffer buffer) {
        if (buffer == null || !buffer.hasRemaining()) {
            return;
        }
        int pos = buffer.position();
        int limit = buffer.limit();
        byte[] bytes = new byte[buffer.remaining()];
        buffer.get(bytes);
        buffer.position(pos);
        buffer.limit(limit);
        println(string, bytes);
    }

    /**
     * 将字节数组的内容转换成字符串并打印到控制台, string参数不为空时会追加在字节数组内容字符串之前
     *
     * @param string 字符串前缀
     * @param bytes  字节数组
     *
     */
    public static void println(String string, byte... bytes) {
        if (bytes == null) {
            return;
        }
        StringBuilder sb = new StringBuilder();
        if (string != null) {
            sb.append(string);
        }
        sb.append(bytes.length).append(".[");
        boolean last = false;
        for (byte b : bytes) {
            if (last) {
                sb.append(',');
            }
            int v = b & 0xff;
            sb.append("0x");
            if (v < 16) {
                sb.append('0');
            }
            sb.append(Integer.toHexString(v));
            last = true;
        }
        sb.append(']');
        (System.out).println(sb);
    }

    /**
     * 返回本机的第一个内网IPv4地址， 没有则返回null
     *
     * @return IPv4地址
     */
    public static InetAddress localInetAddress() {
        InetAddress back = null;
        try {
            Enumeration<NetworkInterface> nifs = NetworkInterface.getNetworkInterfaces();
            while (nifs.hasMoreElements()) {
                NetworkInterface nif = nifs.nextElement();
                if (!nif.isUp()) {
                    continue;
                }
                Enumeration<InetAddress> eis = nif.getInetAddresses();
                while (eis.hasMoreElements()) {
                    InetAddress ia = eis.nextElement();
                    if (ia.isLoopbackAddress() && ia instanceof Inet4Address) {
                        back = ia;
                    }
                    if (ia.isSiteLocalAddress() && ia instanceof Inet4Address) {
                        return ia;
                    }
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return back;
    }

    /**
     * 创建 CompletionHandler 对象
     *
     * @param <V>     结果对象的泛型
     * @param <A>     附件对象的泛型
     * @param success 成功的回调函数
     * @param fail    失败的回调函数
     *
     * @return CompletionHandler
     */
    public static <V, A> CompletionHandler<V, A> createAsyncHandler(final BiConsumer<V, A> success, final BiConsumer<Throwable, A> fail) {
        return new CompletionHandler<V, A>() {
            @Override
            public void completed(V result, A attachment) {
                if (success != null) {
                    success.accept(result, attachment);
                }
            }

            @Override
            public void failed(Throwable exc, A attachment) {
                if (fail != null) {
                    fail.accept(exc, attachment);
                }
            }
        };
    }

    /**
     * 创建没有返回结果的 CompletionHandler 对象
     *
     * @param <A>     附件对象的泛型
     * @param success 成功的回调函数
     * @param fail    失败的回调函数
     *
     * @return CompletionHandler
     */
    public static <A> CompletionHandler<Void, A> createAsyncHandler(final Consumer<A> success, final BiConsumer<Throwable, A> fail) {
        return new CompletionHandler<Void, A>() {
            @Override
            public void completed(Void result, A attachment) {
                if (success != null) {
                    success.accept(attachment);
                }
            }

            @Override
            public void failed(Throwable exc, A attachment) {
                if (fail != null) {
                    fail.accept(exc, attachment);
                }
            }
        };
    }

    /**
     * 创建没有附件对象的 CompletionHandler 对象
     *
     * @param <V>     结果对象的泛型
     * @param success 成功的回调函数
     * @param fail    失败的回调函数
     *
     * @return CompletionHandler
     */
    public static <V> CompletionHandler<V, Void> createAsyncHandler(final Consumer<V> success, final Consumer<Throwable> fail) {
        return new CompletionHandler<V, Void>() {
            @Override
            public void completed(V result, Void attachment) {
                if (success != null) {
                    success.accept(result);
                }
            }

            @Override
            public void failed(Throwable exc, Void attachment) {
                if (fail != null) {
                    fail.accept(exc);
                }
            }
        };
    }

    /**
     * 获取格式为yyyy-MM-dd HH:mm:ss的当前时间
     *
     * @return 格式为yyyy-MM-dd HH:mm:ss的时间值
     */
    public static String now() {
        return String.format(format1, System.currentTimeMillis());
    }

    /**
     * 获取格式为yyyy-MM-dd HH:mm:ss.fff的当前时间
     *
     * @return 格式为yyyy-MM-dd HH:mm:ss.fff的时间值
     */
    public static String nowMillis() {
        return String.format(format2, System.currentTimeMillis());
    }

    /**
     * 将指定时间格式化为 yyyy-MM-dd HH:mm:ss
     *
     * @param time 待格式化的时间
     *
     * @return 格式为yyyy-MM-dd HH:mm:ss的时间值
     */
    public static String formatTime(long time) {
        return String.format(format1, time);
    }

    /**
     * 将时间值转换为长度为9的36进制值
     *
     * @param time 时间值
     *
     * @return 36进制时间值
     */
    public static String format36time(long time) {
        return Long.toString(time, 36);
    }

    /**
     * 获取当天凌晨零点的格林时间
     *
     * @return 毫秒数
     */
    public static long midnight() {
        return midnight(System.currentTimeMillis());
    }

    /**
     * 获取指定时间当天凌晨零点的格林时间
     *
     * @param time 指定时间
     *
     * @return 毫秒数
     */
    public static long midnight(long time) {
        return (time + zoneRawOffset) / 86400000 * 86400000 - zoneRawOffset;
    }

    /**
     * 获取当天20151231格式的int值
     *
     * @return 20151231格式的int值
     */
    public static int today() {
        java.time.LocalDate today = java.time.LocalDate.now();
        return today.getYear() * 10000 + today.getMonthValue() * 100 + today.getDayOfMonth();
    }

    /**
     * 获取当天151231格式的int值
     *
     * @return 151231格式的int值
     */
    public static int todayYYMMDD() {
        java.time.LocalDate today = java.time.LocalDate.now();
        return today.getYear() % 100 * 10000 + today.getMonthValue() * 100 + today.getDayOfMonth();
    }

    /**
     * 获取当天1512312359格式的int值
     *
     * @return 1512312359格式的int值
     */
    public static int todayYYMMDDHHmm() {
        java.time.LocalDateTime today = java.time.LocalDateTime.now();
        return today.getYear() % 100 * 100_00_00_00 + today.getMonthValue() * 100_00_00 + today.getDayOfMonth() * 100_00
            + today.getHour() * 100 + today.getMinute();
    }

    /**
     * 获取当天20151231235959格式的int值
     *
     * @return 20151231235959格式的int值
     */
    public static long todayYYYYMMDDHHmmss() {
        java.time.LocalDateTime today = java.time.LocalDateTime.now();
        return today.getYear() * 100_00_00_00_00L + today.getMonthValue() * 100_00_00_00 + today.getDayOfMonth() * 100_00_00
            + today.getHour() * 100_00 + today.getMinute() * 100 + today.getSecond();
    }

    /**
     * 获取当天151231235959格式的int值
     *
     * @return 151231235959格式的int值
     */
    public static long todayYYMMDDHHmmss() {
        java.time.LocalDateTime today = java.time.LocalDateTime.now();
        return today.getYear() % 100 * 100_00_00_00_00L + today.getMonthValue() * 100_00_00_00 + today.getDayOfMonth() * 100_00_00
            + today.getHour() * 100_00 + today.getMinute() * 100 + today.getSecond();
    }

    /**
     * 获取明天20151230格式的int值
     *
     * @return 20151230格式的int值
     */
    public static int tomorrow() {
        Calendar cal = Calendar.getInstance();
        cal.add(Calendar.DAY_OF_YEAR, 1);
        return cal.get(Calendar.YEAR) * 10000 + (cal.get(Calendar.MONTH) + 1) * 100 + cal.get(Calendar.DAY_OF_MONTH);
    }

    /**
     * 获取明天151230格式的int值
     *
     * @return 151230格式的int值
     */
    public static int tomorrowYYMMDD() {
        Calendar cal = Calendar.getInstance();
        cal.add(Calendar.DAY_OF_YEAR, 1);
        return cal.get(Calendar.YEAR) % 100 * 10000 + (cal.get(Calendar.MONTH) + 1) * 100 + cal.get(Calendar.DAY_OF_MONTH);
    }

    /**
     * 获取昨天20151230格式的int值
     *
     * @return 20151230格式的int值
     */
    public static int yesterday() {
        Calendar cal = Calendar.getInstance();
        cal.add(Calendar.DAY_OF_YEAR, -1);
        return cal.get(Calendar.YEAR) * 10000 + (cal.get(Calendar.MONTH) + 1) * 100 + cal.get(Calendar.DAY_OF_MONTH);
    }

    /**
     * 获取昨天151230格式的int值
     *
     * @return 151230格式的int值
     */
    public static int yesterdayYYMMDD() {
        Calendar cal = Calendar.getInstance();
        cal.add(Calendar.DAY_OF_YEAR, -1);
        return cal.get(Calendar.YEAR) % 100 * 10000 + (cal.get(Calendar.MONTH) + 1) * 100 + cal.get(Calendar.DAY_OF_MONTH);
    }

    /**
     * 获取指定时间的20160202格式的int值
     *
     * @param time 指定时间
     *
     * @return 毫秒数
     */
    public static int yyyyMMdd(long time) {
        Calendar cal = Calendar.getInstance();
        cal.setTimeInMillis(time);
        return cal.get(Calendar.YEAR) * 10000 + (cal.get(Calendar.MONTH) + 1) * 100 + cal.get(Calendar.DAY_OF_MONTH);
    }

    /**
     * 获取指定时间的160202格式的int值
     *
     * @param time 指定时间
     *
     * @return 毫秒数
     */
    public static int yyMMdd(long time) {
        Calendar cal = Calendar.getInstance();
        cal.setTimeInMillis(time);
        return cal.get(Calendar.YEAR) % 100 * 10000 + (cal.get(Calendar.MONTH) + 1) * 100 + cal.get(Calendar.DAY_OF_MONTH);
    }

    /**
     * 获取当天16020223格式的int值
     *
     * @param time 指定时间
     *
     * @return 16020223格式的int值
     */
    public static int yyMMDDHHmm(long time) {
        Calendar cal = Calendar.getInstance();
        cal.setTimeInMillis(time);
        return cal.get(Calendar.YEAR) % 100 * 100_00_00 + (cal.get(Calendar.MONTH) + 1) * 100_00 + cal.get(Calendar.DAY_OF_MONTH) * 100 + cal.get(Calendar.HOUR_OF_DAY);
    }

    /**
     * 获取时间点所在星期的周一
     *
     * @param time 指定时间
     *
     * @return 毫秒数
     */
    public static long monday(long time) {
        ZoneId zid = ZoneId.systemDefault();
        Instant instant = Instant.ofEpochMilli(time);
        LocalDate ld = instant.atZone(zid).toLocalDate();
        ld = ld.minusDays(ld.getDayOfWeek().getValue() - 1);
        return ld.atStartOfDay(zid).toInstant().toEpochMilli();
    }

    /**
     * 获取时间点所在星期的周日
     *
     * @param time 指定时间
     *
     * @return 毫秒数
     */
    public static long sunday(long time) {
        ZoneId zid = ZoneId.systemDefault();
        Instant instant = Instant.ofEpochMilli(time);
        LocalDate ld = instant.atZone(zid).toLocalDate();
        ld = ld.plusDays(7 - ld.getDayOfWeek().getValue());
        return ld.atStartOfDay(zid).toInstant().toEpochMilli();
    }

    /**
     * 获取时间点所在月份的1号
     *
     * @param time 指定时间
     *
     * @return 毫秒数
     */
    public static long monthFirstDay(long time) {
        ZoneId zid = ZoneId.systemDefault();
        Instant instant = Instant.ofEpochMilli(time);
        LocalDate ld = instant.atZone(zid).toLocalDate().withDayOfMonth(1);
        return ld.atStartOfDay(zid).toInstant().toEpochMilli();
    }

    /**
     * 获取时间点所在月份的最后一天
     *
     * @param time 指定时间
     *
     * @return 毫秒数
     */
    public static long monthLastDay(long time) {
        ZoneId zid = ZoneId.systemDefault();
        Instant instant = Instant.ofEpochMilli(time);
        LocalDate ld = instant.atZone(zid).toLocalDate();
        ld = ld.withDayOfMonth(ld.lengthOfMonth());
        return ld.atStartOfDay(zid).toInstant().toEpochMilli();
    }

    /**
     * 将时间格式化, 支持%1$ty 和 %ty两种格式
     *
     * @param format 格式
     * @param size   带%t的个数，值小于0则需要计算
     * @param time   时间
     *
     * @since 2.7.0
     *
     * @return 时间格式化
     */
    public static String formatTime(String format, int size, Object time) {
        if (size < 0) {
            int c = 0;
            if (!format.contains("%1$")) {
                for (char ch : format.toCharArray()) {
                    if (ch == '%') {
                        c++;
                    }
                }
            }
            size = c;
        }
        if (size <= 1) {
            return String.format(format, time);
        }
        if (size == 2) {
            return String.format(format, time, time);
        }
        if (size == 3) {
            return String.format(format, time, time, time);
        }
        if (size == 4) {
            return String.format(format, time, time, time, time);
        }
        if (size == 5) {
            return String.format(format, time, time, time, time, time);
        }
        if (size == 6) {
            return String.format(format, time, time, time, time, time, time);
        }
        if (size == 7) {
            return String.format(format, time, time, time, time, time, time, time);
        }
        if (size == 8) {
            return String.format(format, time, time, time, time, time, time, time);
        }
        Object[] args = new Object[size];
        for (int i = 0; i < size; i++) {
            args[i] = time;
        }
        return String.format(format, args);
    }

    /**
     * 将int[]强制转换成byte[]
     *
     * @param value int[]
     *
     * @return byte[]
     */
    public static byte[] intsToBytes(int[] value) {
        if (value == null) {
            return null;
        }
        byte[] bs = new byte[value.length];
        for (int i = 0; i < bs.length; i++) {
            bs[i] = (byte) value[i];
        }
        return bs;
    }

    /**
     * MD5加密
     *
     * @param str 待加密数据
     *
     * @return md5值
     */
    public static String md5Hex(String str) {
        return binToHexString(md5(str));
    }

    /**
     * MD5加密
     *
     * @param input 待加密数据
     *
     * @return md5值
     */
    public static String md5Hex(byte[] input) {
        return binToHexString(md5(input));
    }

    /**
     * MD5加密
     *
     * @param str 待加密数据
     *
     * @return md5值
     */
    public static byte[] md5(String str) {
        if (str == null) {
            return null;
        }
        MessageDigest md5;
        try {
            md5 = MessageDigest.getInstance("MD5");
        } catch (NoSuchAlgorithmException ex) {
            throw new RedkaleException("Couldn't find a MD5 provider", ex);
        }
        return md5.digest(str.getBytes(StandardCharsets.UTF_8));
    }

    /**
     * MD5加密
     *
     * @param input 待加密数据
     *
     * @return md5值
     */
    public static byte[] md5(byte[] input) {
        if (input == null) {
            return null;
        }
        MessageDigest md5;
        try {
            md5 = MessageDigest.getInstance("MD5");
        } catch (NoSuchAlgorithmException ex) {
            throw new RedkaleException("Couldn't find a MD5 provider", ex);
        }
        return md5.digest(input);
    }

    /**
     * MD5加密
     *
     * @param input  待加密数据
     * @param offset 偏移量
     * @param len    长度
     *
     * @return md5值
     */
    public static byte[] md5(byte[] input, int offset, int len) {
        if (input == null) {
            return null;
        }
        MessageDigest md5;
        try {
            md5 = MessageDigest.getInstance("MD5");
            md5.update(input, offset, len);
            return md5.digest();
        } catch (NoSuchAlgorithmException ex) {
            throw new RedkaleException("Couldn't find a MD5 provider", ex);
        }
    }

    /**
     * SHA-256
     *
     * @param str 待hash数据
     *
     * @return hash值
     */
    public static String sha256Hex(String str) {
        return binToHexString(sha256(str));
    }

    /**
     * SHA-256
     *
     * @param input 待hash数据
     *
     * @return hash值
     */
    public static String sha256Hex(byte[] input) {
        return binToHexString(sha256(input));
    }

    /**
     * SHA-256
     *
     * @param input  待hash数据
     * @param offset 偏移量
     * @param len    长度
     *
     * @return hash值
     */
    public static String sha256Hex(byte[] input, int offset, int len) {
        return binToHexString(sha256(input, offset, len));
    }

    /**
     * 以0x开头的 SHA-256
     *
     * @param input 待hash数据
     *
     * @return hash值
     */
    public static String sha256Hex0x(byte[] input) {
        return binTo0xHexString(sha256(input));
    }

    /**
     * 以0x开头的 SHA-256
     *
     * @param input  待hash数据
     * @param offset 偏移量
     * @param len    长度
     *
     * @return hash值
     */
    public static String sha256Hex0x(byte[] input, int offset, int len) {
        return binTo0xHexString(sha256(input, offset, len));
    }

    /**
     * SHA-256
     *
     * @param str 待hash数据
     *
     * @return hash值
     */
    public static byte[] sha256(String str) {
        if (str == null) {
            return null;
        }
        MessageDigest digester;
        try {
            digester = MessageDigest.getInstance("SHA-256");
        } catch (NoSuchAlgorithmException ex) {
            throw new RedkaleException("Couldn't find a SHA-256 provider", ex);
        }
        return digester.digest(str.getBytes(StandardCharsets.UTF_8));
    }

    /**
     * SHA-256
     *
     * @param input 待hash数据
     *
     * @return hash值
     */
    public static byte[] sha256(byte[] input) {
        if (input == null) {
            return null;
        }
        MessageDigest digester;
        try {
            digester = MessageDigest.getInstance("SHA-256");
        } catch (NoSuchAlgorithmException ex) {
            throw new RedkaleException(ex);
        }
        return digester.digest(input);
    }

    /**
     * SHA-256
     *
     * @param input  待hash数据
     * @param offset 偏移量
     * @param len    长度
     *
     * @return hash值
     */
    public static byte[] sha256(byte[] input, int offset, int len) {
        if (input == null) {
            return null;
        }
        MessageDigest digester;
        try {
            digester = MessageDigest.getInstance("SHA-256");
            digester.update(input, offset, len);
            return digester.digest();
        } catch (Exception ex) {
            throw new RedkaleException(ex);
        }
    }

    /**
     * HmacSHA1
     *
     * @param key   密钥
     * @param input 待hash数据
     *
     * @return hash值
     */
    public static String hmacSha1Base64(String key, String input) {
        return Base64.getEncoder().encodeToString(hmacSha1(key.getBytes(UTF_8), input.getBytes(UTF_8)));
    }

    /**
     * HmacSHA1
     *
     * @param key   密钥
     * @param input 待hash数据
     *
     * @return hash值
     */
    public static String hmacSha1Base64(byte[] key, byte[] input) {
        return Base64.getEncoder().encodeToString(hmacSha1(key, input));
    }

    /**
     * HmacSHA1
     *
     * @param key    密钥
     * @param input  待hash数据
     * @param offset 偏移量
     * @param len    长度
     *
     * @return hash值
     */
    public static String hmacSha1Base64(byte[] key, byte[] input, int offset, int len) {
        return Base64.getEncoder().encodeToString(hmacSha1(key, input, offset, len));
    }

    /**
     * HmacSHA1
     *
     * @param key   密钥
     * @param input 待hash数据
     *
     * @return hash值
     */
    public static String hmacSha1Hex(byte[] key, byte[] input) {
        return binToHexString(hmacSha1(key, input));
    }

    /**
     * HmacSHA1
     *
     * @param key    密钥
     * @param input  待hash数据
     * @param offset 偏移量
     * @param len    长度
     *
     * @return hash值
     */
    public static String hmacSha1Hex(byte[] key, byte[] input, int offset, int len) {
        return binToHexString(hmacSha1(key, input, offset, len));
    }

    /**
     * 以0x开头的 HmacSHA1
     *
     * @param key   密钥
     * @param input 待hash数据
     *
     * @return hash值
     */
    public static String hmacSha1Hex0x(byte[] key, byte[] input) {
        return binTo0xHexString(hmacSha1(key, input));
    }

    /**
     * 以0x开头的 HmacSHA1
     *
     * @param key    密钥
     * @param input  待hash数据
     * @param offset 偏移量
     * @param len    长度
     *
     * @return hash值
     */
    public static String hmacSha1Hex0x(byte[] key, byte[] input, int offset, int len) {
        return binTo0xHexString(hmacSha1(key, input, offset, len));
    }

    /**
     * HmacSHA1
     *
     * @param key   密钥
     * @param input 待hash数据
     *
     * @return hash值
     */
    public static byte[] hmacSha1(byte[] key, byte[] input) {
        if (input == null) {
            return null;
        }
        try {
            Mac mac = Mac.getInstance("HmacSHA1");
            mac.init(new SecretKeySpec(key, "HmacSHA1"));
            return mac.doFinal(input);
        } catch (InvalidKeyException | NoSuchAlgorithmException ex) {
            throw new RedkaleException(ex);
        }
    }

    /**
     * HmacSHA1
     *
     * @param key    密钥
     * @param input  待hash数据
     * @param offset 偏移量
     * @param len    长度
     *
     * @return hash值
     */
    public static byte[] hmacSha1(byte[] key, byte[] input, int offset, int len) {
        if (input == null) {
            return null;
        }
        try {
            Mac mac = Mac.getInstance("HmacSHA1");
            mac.init(new SecretKeySpec(key, "HmacSHA1"));
            mac.update(input, offset, len);
            return mac.doFinal();
        } catch (InvalidKeyException | NoSuchAlgorithmException ex) {
            throw new RedkaleException(ex);
        }
    }

    /**
     * HmacSHA256
     *
     * @param key   密钥
     * @param input 待hash数据
     *
     * @return hash值
     */
    public static String hmacSha256Base64(String key, String input) {
        return Base64.getEncoder().encodeToString(hmacSha256(key.getBytes(UTF_8), input.getBytes(UTF_8)));
    }

    /**
     * HmacSHA256
     *
     * @param key   密钥
     * @param input 待hash数据
     *
     * @return hash值
     */
    public static String hmacSha256Base64(byte[] key, byte[] input) {
        return Base64.getEncoder().encodeToString(hmacSha256(key, input));
    }

    /**
     * HmacSHA256
     *
     * @param key    密钥
     * @param input  待hash数据
     * @param offset 偏移量
     * @param len    长度
     *
     * @return hash值
     */
    public static String hmacSha256Base64(byte[] key, byte[] input, int offset, int len) {
        return Base64.getEncoder().encodeToString(hmacSha256(key, input, offset, len));
    }

    /**
     * HmacSHA256
     *
     * @param key   密钥
     * @param input 待hash数据
     *
     * @return hash值
     */
    public static String hmacSha256Hex(byte[] key, byte[] input) {
        return binToHexString(hmacSha256(key, input));
    }

    /**
     * HmacSHA256
     *
     * @param key    密钥
     * @param input  待hash数据
     * @param offset 偏移量
     * @param len    长度
     *
     * @return hash值
     */
    public static String hmacSha256Hex(byte[] key, byte[] input, int offset, int len) {
        return binToHexString(hmacSha256(key, input, offset, len));
    }

    /**
     * 以0x开头的 HmacSHA256
     *
     * @param key   密钥
     * @param input 待hash数据
     *
     * @return hash值
     */
    public static String hmacSha256Hex0x(byte[] key, byte[] input) {
        return binTo0xHexString(hmacSha256(key, input));
    }

    /**
     * 以0x开头的 HmacSHA256
     *
     * @param key    密钥
     * @param input  待hash数据
     * @param offset 偏移量
     * @param len    长度
     *
     * @return hash值
     */
    public static String hmacSha256Hex0x(byte[] key, byte[] input, int offset, int len) {
        return binTo0xHexString(hmacSha256(key, input, offset, len));
    }

    /**
     * HmacSHA256
     *
     * @param key   密钥
     * @param input 待hash数据
     *
     * @return hash值
     */
    public static byte[] hmacSha256(byte[] key, byte[] input) {
        if (input == null) {
            return null;
        }
        try {
            Mac mac = Mac.getInstance("HmacSHA256");
            mac.init(new SecretKeySpec(key, "HmacSHA256"));
            return mac.doFinal(input);
        } catch (InvalidKeyException | NoSuchAlgorithmException ex) {
            throw new RedkaleException(ex);
        }
    }

    /**
     * HmacSHA256
     *
     * @param key    密钥
     * @param input  待hash数据
     * @param offset 偏移量
     * @param len    长度
     *
     * @return hash值
     */
    public static byte[] hmacSha256(byte[] key, byte[] input, int offset, int len) {
        if (input == null) {
            return null;
        }
        try {
            Mac mac = Mac.getInstance("HmacSHA256");
            mac.init(new SecretKeySpec(key, "HmacSHA256"));
            mac.update(input, offset, len);
            return mac.doFinal();
        } catch (InvalidKeyException | NoSuchAlgorithmException ex) {
            throw new RedkaleException(ex);
        }
    }

    /**
     * HmacSHA512
     *
     * @param key   密钥
     * @param input 待hash数据
     *
     * @return hash值
     */
    public static String hmacSha512Base64(String key, String input) {
        return Base64.getEncoder().encodeToString(hmacSha512(key.getBytes(UTF_8), input.getBytes(UTF_8)));
    }

    /**
     * HmacSHA512
     *
     * @param key   密钥
     * @param input 待hash数据
     *
     * @return hash值
     */
    public static String hmacSha512Base64(byte[] key, byte[] input) {
        return Base64.getEncoder().encodeToString(hmacSha512(key, input));
    }

    /**
     * HmacSHA512
     *
     * @param key    密钥
     * @param input  待hash数据
     * @param offset 偏移量
     * @param len    长度
     *
     * @return hash值
     */
    public static String hmacSha512Base64(byte[] key, byte[] input, int offset, int len) {
        return Base64.getEncoder().encodeToString(hmacSha512(key, input, offset, len));
    }

    /**
     * HmacSHA512
     *
     * @param key   密钥
     * @param input 待hash数据
     *
     * @return hash值
     */
    public static String hmacSha512Hex(byte[] key, byte[] input) {
        return binToHexString(hmacSha512(key, input));
    }

    /**
     * HmacSHA512
     *
     * @param key    密钥
     * @param input  待hash数据
     * @param offset 偏移量
     * @param len    长度
     *
     * @return hash值
     */
    public static String hmacSha512Hex(byte[] key, byte[] input, int offset, int len) {
        return binToHexString(hmacSha512(key, input, offset, len));
    }

    /**
     * 以0x开头的 HmacSHA512
     *
     * @param key   密钥
     * @param input 待hash数据
     *
     * @return hash值
     */
    public static String hmacSha512Hex0x(byte[] key, byte[] input) {
        return binTo0xHexString(hmacSha512(key, input));
    }

    /**
     * 以0x开头的 HmacSHA512
     *
     * @param key    密钥
     * @param input  待hash数据
     * @param offset 偏移量
     * @param len    长度
     *
     * @return hash值
     */
    public static String hmacSha512Hex0x(byte[] key, byte[] input, int offset, int len) {
        return binTo0xHexString(hmacSha512(key, input, offset, len));
    }

    /**
     * HmacSHA512
     *
     * @param key   密钥
     * @param input 待hash数据
     *
     * @return hash值
     */
    public static byte[] hmacSha512(byte[] key, byte[] input) {
        if (input == null) {
            return null;
        }
        try {
            SecretKey sk = new SecretKeySpec(key, "HmacSHA512");
            Mac mac = Mac.getInstance("HmacSHA512");
            mac.init(sk);
            return mac.doFinal(input);
        } catch (InvalidKeyException | NoSuchAlgorithmException ex) {
            throw new RedkaleException(ex);
        }
    }

    /**
     * HmacSHA512
     *
     * @param key    密钥
     * @param input  待hash数据
     * @param offset 偏移量
     * @param len    长度
     *
     * @return hash值
     */
    public static byte[] hmacSha512(byte[] key, byte[] input, int offset, int len) {
        if (input == null) {
            return null;
        }
        try {
            SecretKey sk = new SecretKeySpec(key, "HmacSHA512");
            Mac mac = Mac.getInstance("HmacSHA512");
            mac.init(sk);
            mac.update(input, offset, len);
            return mac.doFinal();
        } catch (InvalidKeyException | NoSuchAlgorithmException ex) {
            throw new RedkaleException(ex);
        }
    }

    /**
     * 根据指定算法进行hash
     *
     * @param algorithm 算法名
     * @param input     待hash数据
     *
     * @return hash值
     */
    public static byte[] hash(String algorithm, byte[] input) {
        try {
            MessageDigest digest = MessageDigest.getInstance(algorithm.toUpperCase());
            return digest.digest(input);
        } catch (NoSuchAlgorithmException ex) {
            throw new RedkaleException("Couldn't find a " + algorithm + " provider", ex);
        }
    }

    /**
     * 根据指定算法进行hash
     *
     * @param algorithm 算法名
     * @param input     待hash数据
     * @param offset    偏移量
     * @param length    长度
     *
     * @return hash值
     */
    public static byte[] hash(String algorithm, byte[] input, int offset, int length) {
        try {
            MessageDigest digest = MessageDigest.getInstance(algorithm.toUpperCase());
            digest.update(input, offset, length);
            return digest.digest();
        } catch (NoSuchAlgorithmException ex) {
            throw new RedkaleException("Couldn't find a " + algorithm + " provider", ex);
        }
    }

    /**
     * 随机
     *
     * @return 随机
     */
    public static SecureRandom secureRandom() {
        return random;
    }

    /**
     * 生成随机数
     *
     * @param size 随机数长度
     *
     * @return 随机数
     */
    public static byte[] generateRandomBytes(int size) {
        byte[] bytes = new byte[size];
        random.nextBytes(bytes);
        return bytes;
    }

    /**
     * 将字节数组转换为以0x开头的16进制字符串
     *
     * @param bytes 字节数组
     *
     * @return 16进制字符串
     */
    public static String binTo0xHexString(byte[] bytes) {
        return "0x" + new String(binToHex(bytes));
    }

    /**
     * 将字节数组转换为以0x开头的16进制字符串
     *
     * @param bytes  字节数组
     * @param offset 偏移量
     * @param len    长度
     *
     * @return 16进制字符串
     */
    public static String binTo0xHexString(byte[] bytes, int offset, int len) {
        return "0x" + new String(binToHex(bytes, offset, len));
    }

    /**
     * 将字节数组转换为16进制字符串
     *
     * @param bytes 字节数组
     *
     * @return 16进制字符串
     */
    public static String binToHexString(byte[] bytes) {
        return new String(binToHex(bytes));
    }

    /**
     * 将字节数组转换为16进制字符数组
     *
     * @param bytes 字节数组
     *
     * @return 16进制字符串的字符数组
     */
    public static char[] binToHex(byte[] bytes) {
        return binToHex(bytes, 0, bytes.length);
    }

    /**
     * 将字节数组转换为16进制字符串
     *
     * @param bytes  字节数组
     * @param offset 偏移量
     * @param len    长度
     *
     * @return 16进制字符串
     */
    public static String binToHexString(byte[] bytes, int offset, int len) {
        return new String(binToHex(bytes, offset, len));
    }

    /**
     * 将字节数组转换为16进制字符数组
     *
     * @param bytes  字节数组
     * @param offset 偏移量
     * @param len    长度
     *
     * @return 16进制字符串的字符数组
     */
    public static char[] binToHex(byte[] bytes, int offset, int len) {
        final char[] sb = new char[len * 2];
        final int end = offset + len;
        int index = 0;
        final char[] hexs = hex;
        for (int i = offset; i < end; i++) {
            byte b = bytes[i];
            sb[index++] = (hexs[((b >> 4) & 0xF)]);
            sb[index++] = hexs[((b) & 0xF)];
        }
        return sb;
    }

    /**
     * 将16进制字符串转换成字节数组
     *
     * @param src 16进制字符串
     *
     * @return 字节数组
     */
    public static byte[] hexToBin(CharSequence src) {
        return hexToBin(src, 0, src.length());
    }

    /**
     *
     * 将16进制字符串转换成字节数组
     *
     * @param src    16进制字符串
     * @param offset 偏移量
     * @param len    长度
     *
     * @return 字节数组
     */
    public static byte[] hexToBin(CharSequence src, int offset, int len) {
        if (offset == 0 && src.length() > 2 && src.charAt(0) == '0' && (src.charAt(1) == 'x' || src.charAt(1) == 'X')) {
            offset += 2;
            len -= 2;
        }
        final int size = (len + 1) / 2;
        final byte[] bytes = new byte[size];
        String digits = "0123456789abcdef";
        for (int i = 0; i < size; i++) {
            int ch1 = src.charAt(offset + i * 2);
            if ('A' <= ch1 && 'F' >= ch1) {
                ch1 = ch1 - 'A' + 'a';
            }
            int ch2 = src.charAt(offset + i * 2 + 1);
            if ('A' <= ch2 && 'F' >= ch2) {
                ch2 = ch2 - 'A' + 'a';
            }
            int pos1 = digits.indexOf(ch1);
            if (pos1 < 0) {
                throw new NumberFormatException();
            }
            int pos2 = digits.indexOf(ch2);
            if (pos2 < 0) {
                throw new NumberFormatException();
            }
            bytes[i] = (byte) (pos1 * 0x10 + pos2);
        }
        return bytes;
    }

    /**
     *
     * 将16进制字符串转换成字节数组
     *
     * @param str 16进制字符串
     *
     * @return 字节数组
     */
    public static byte[] hexToBin(String str) {
        return hexToBin(charArray(str));
    }

    /**
     *
     * 将16进制字符数组转换成字节数组
     *
     * @param src 16进制字符数组
     *
     * @return 字节数组
     */
    public static byte[] hexToBin(char[] src) {
        return hexToBin(src, 0, src.length);
    }

    /**
     * 将16进制字符数组转换成字节数组
     *
     * @param src    16进制字符数组
     * @param offset 偏移量
     * @param len    长度
     *
     * @return 字节数组
     */
    public static byte[] hexToBin(char[] src, int offset, int len) {
        if (offset == 0 && src.length > 2 && src[0] == '0' && (src[1] == 'x' || src[1] == 'X')) {
            offset += 2;
            len -= 2;
        }
        final int size = (len + 1) / 2;
        final byte[] bytes = new byte[size];
        String digits = "0123456789abcdef";
        for (int i = 0; i < size; i++) {
            int ch1 = src[offset + i * 2];
            if ('A' <= ch1 && 'F' >= ch1) {
                ch1 = ch1 - 'A' + 'a';
            }
            int ch2 = src[offset + i * 2 + 1];
            if ('A' <= ch2 && 'F' >= ch2) {
                ch2 = ch2 - 'A' + 'a';
            }
            int pos1 = digits.indexOf(ch1);
            if (pos1 < 0) {
                throw new NumberFormatException();
            }
            int pos2 = digits.indexOf(ch2);
            if (pos2 < 0) {
                throw new NumberFormatException();
            }
            bytes[i] = (byte) (pos1 * 0x10 + pos2);
        }
        return bytes;
    }

    //-----------------------------------------------------------------------------
    /**
     * 使用UTF-8编码将byte[]转换成char[]
     *
     * @param array byte[]
     *
     * @return char[]
     */
    public static char[] decodeUTF8(final byte[] array) {
        return decodeUTF8(array, 0, array.length);
    }

    public static char[] decodeUTF8(final byte[] array, final int start, final int len) {
        byte b;
        int size = len;
        final byte[] bytes = array;
        final int limit = start + len;
        for (int i = start; i < limit; i++) {
            b = bytes[i];
            if ((b >> 5) == -2) {// 2 bytes, 11 bits: 110xxxxx 10xxxxxx
                size--;
            } else if ((b >> 4) == -2) {// 3 bytes, 16 bits: 1110xxxx 10xxxxxx 10xxxxxx
                size -= 2;
            } else if ((b >> 3) == -2) {// 4 bytes, 21 bits: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
                size -= 2;
            }
        }
        final char[] text = new char[size];
        size = 0;
        for (int i = start; i < limit;) {
            b = bytes[i++];
            if (b >= 0) {// 1 byte, 7 bits: 0xxxxxxx
                text[size++] = (char) b;
            } else if ((b >> 5) == -2) {// 2 bytes, 11 bits: 110xxxxx 10xxxxxx
                text[size++] = (char) (((b << 6) ^ bytes[i++]) ^ (((byte) 0xC0 << 6) ^ ((byte) 0x80)));
            } else if ((b >> 4) == -2) {// 3 bytes, 16 bits: 1110xxxx 10xxxxxx 10xxxxxx
                text[size++] = (char) ((b << 12) ^ (bytes[i++] << 6) ^ (bytes[i++] ^ (((byte) 0xE0 << 12) ^ ((byte) 0x80 << 6) ^ ((byte) 0x80))));
            } else if ((b >> 3) == -2) {// 4 bytes, 21 bits: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
                int uc = ((b << 18) ^ (bytes[i++] << 12) ^ (bytes[i++] << 6) ^ (bytes[i++] ^ (((byte) 0xF0 << 18) ^ ((byte) 0x80 << 12) ^ ((byte) 0x80 << 6) ^ ((byte) 0x80))));
                text[size++] = Character.highSurrogate(uc);
                text[size++] = Character.lowSurrogate(uc);
                //测试代码 byte[] bs = {(byte)34, (byte)76, (byte)105, (byte)108, (byte)121, (byte)240, (byte)159, (byte)146, (byte)171, (byte)34};
            }
        }
        return text;
    }

    public static byte[] encodeUTF8(final String value) {
        if (value == null) {
            return new byte[0];
        }
        if (strCharFunction == null) {
            return encodeUTF8(value.toCharArray());
        }
        return encodeUTF8((char[]) strCharFunction.apply(value));
    }

    public static byte[] encodeUTF8(final char[] array) {
        return encodeUTF8(array, 0, array.length);
    }

    public static byte[] encodeUTF8(final char[] text, final int start, final int len) {
        char c;
        int size = 0;
        final char[] chs = text;
        final int limit = start + len;
        for (int i = start; i < limit; i++) {
            c = chs[i];
            if (c < 0x80) {
                size++;
            } else if (c < 0x800) {
                size += 2;
            } else if (Character.isSurrogate(c)) {
                size += 2;
            } else {
                size += 3;
            }
        }
        final byte[] bytes = new byte[size];
        size = 0;
        for (int i = start; i < limit; i++) {
            c = chs[i];
            if (c < 0x80) {
                bytes[size++] = (byte) c;
            } else if (c < 0x800) {
                bytes[size++] = (byte) (0xc0 | (c >> 6));
                bytes[size++] = (byte) (0x80 | (c & 0x3f));
            } else if (Character.isSurrogate(c)) { //连取两个
                int uc = Character.toCodePoint(c, chs[i + 1]);
                bytes[size++] = (byte) (0xf0 | ((uc >> 18)));
                bytes[size++] = (byte) (0x80 | ((uc >> 12) & 0x3f));
                bytes[size++] = (byte) (0x80 | ((uc >> 6) & 0x3f));
                bytes[size++] = (byte) (0x80 | (uc & 0x3f));
                i++;
            } else {
                bytes[size++] = (byte) (0xe0 | ((c >> 12)));
                bytes[size++] = (byte) (0x80 | ((c >> 6) & 0x3f));
                bytes[size++] = (byte) (0x80 | (c & 0x3f));
            }
        }
        return bytes;
    }

    public static long getAddress(ByteBuffer buffer) {
        return bufferAddrFunction.applyAsLong(buffer);
    }

    public static boolean isLatin1(String value) {
        if (value == null) {
            return true;
        }
        if (strLatin1Function != null) {
            return strLatin1Function.test(value); //LATIN1:0  UTF16:1
        }
        char[] chs = charArray(value);
        for (char ch : chs) {
            if (ch >= 0x80) {
                return false;
            }
        }
        return true;
    }

    public static char[] charArray(String value) {
        if (value == null) {
            return null;
        }
        if (strCharFunction == null) {
            return value.toCharArray();
        }
        return (char[]) strCharFunction.apply(value);
    }

    public static char[] charArray(StringBuilder value) {
        if (value == null) {
            return null;
        }
        if (sbCharFunction == null) {
            return value.toString().toCharArray();
        }
        return (char[]) sbCharFunction.apply(value);
    }

    //只能是单字节字符串
    public static byte[] latin1ByteArray(String latin1Value) {
        if (latin1Value == null) {
            return null;
        }
        if (strByteFunction == null) {
            return latin1Value.getBytes();
        }
        return (byte[]) strByteFunction.apply(latin1Value);
    }

    //只能是单字节字符串
    public static byte[] latin1ByteArray(StringBuilder latin1Value) {
        if (latin1Value == null) {
            return null;
        }
        if (sbByteFunction == null) {
            return latin1Value.toString().getBytes();
        }
        return (byte[]) sbByteFunction.apply(latin1Value);
    }

    public static ByteBuffer encodeUTF8(final ByteBuffer buffer, final char[] array) {
        return encodeUTF8(buffer, array, 0, array.length);
    }

    public static ByteBuffer encodeUTF8(final ByteBuffer buffer, int bytesLength, final char[] array) {
        return encodeUTF8(buffer, bytesLength, array, 0, array.length);
    }

    public static int encodeUTF8Length(String value) {
        if (value == null) {
            return -1;
        }
        if (strCharFunction == null) {
            return encodeUTF8Length(value.toCharArray());
        }
        return encodeUTF8Length((char[]) strCharFunction.apply(value));
    }

    public static int encodeUTF8Length(final char[] text) {
        return encodeUTF8Length(text, 0, text.length);
    }

    public static int encodeUTF8Length(final char[] text, final int start, final int len) {
        char c;
        int size = 0;
        final char[] chs = text;
        final int limit = start + len;
        for (int i = start; i < limit; i++) {
            c = chs[i];
            if (c < 0x80) {
                size++;
            } else if (c < 0x800) {
                size += 2;
            } else if (Character.isSurrogate(c)) {
                size += 2;
            } else {
                size += 3;
            }
        }
        return size;
    }

    /**
     * 将两个数字组装成一个long
     *
     * @param high 高位值
     * @param low  低位值
     *
     * @return long值
     */
    public static long merge(int high, int low) {
        return (0L + high) << 32 | low;
    }

    public static ByteBuffer encodeUTF8(final ByteBuffer buffer, final char[] text, final int start, final int len) {
        return encodeUTF8(buffer, encodeUTF8Length(text, start, len), text, start, len);
    }

    //返回的ByteBuffer为扩展buffer，为null表示参数中的buffer足够存储数据
    public static ByteBuffer encodeUTF8(final ByteBuffer buffer, int bytesLength, final char[] text, final int start, final int len) {
        char c;
        char[] chs = text;
        final int limit = start + len;
        int remain = buffer.remaining();
        final ByteBuffer buffer2 = remain >= bytesLength ? null : ByteBuffer.allocate(bytesLength - remain + 4); //最差情况buffer最后两byte没有填充
        ByteBuffer buf = buffer;
        for (int i = start; i < limit; i++) {
            c = chs[i];
            if (c < 0x80) {
                if (buf.remaining() < 1) {
                    buf = buffer2;
                }
                buf.put((byte) c);
            } else if (c < 0x800) {
                if (buf.remaining() < 2) {
                    buf = buffer2;
                }
                buf.put((byte) (0xc0 | (c >> 6)));
                buf.put((byte) (0x80 | (c & 0x3f)));
            } else if (Character.isSurrogate(c)) { //连取两个
                if (buf.remaining() < 4) {
                    buf = buffer2;
                }
                int uc = Character.toCodePoint(c, chs[i + 1]);
                buf.put((byte) (0xf0 | ((uc >> 18))));
                buf.put((byte) (0x80 | ((uc >> 12) & 0x3f)));
                buf.put((byte) (0x80 | ((uc >> 6) & 0x3f)));
                buf.put((byte) (0x80 | (uc & 0x3f)));
                i++;
            } else {
                if (buf.remaining() < 3) {
                    buf = buffer2;
                }
                buf.put((byte) (0xe0 | ((c >> 12))));
                buf.put((byte) (0x80 | ((c >> 6) & 0x3f)));
                buf.put((byte) (0x80 | (c & 0x3f)));
            }
        }
        if (buffer2 != null) {
            buffer2.flip();
        }
        return buffer2; //返回扩展buffer
    }

    public static String getTypeDescriptor(java.lang.reflect.Type type) {
        if (type == null) {
            return null;
        }
        if (type instanceof Class) {
            Class d = (Class) type;
            final StringBuilder sb = new StringBuilder();
            while (true) {
                if (d.isPrimitive()) {
                    char car;
                    if (d == Integer.TYPE) {
                        car = 'I';
                    } else if (d == Void.TYPE) {
                        car = 'V';
                    } else if (d == Boolean.TYPE) {
                        car = 'Z';
                    } else if (d == Byte.TYPE) {
                        car = 'B';
                    } else if (d == Character.TYPE) {
                        car = 'C';
                    } else if (d == Short.TYPE) {
                        car = 'S';
                    } else if (d == Double.TYPE) {
                        car = 'D';
                    } else if (d == Float.TYPE) {
                        car = 'F';
                    } else /* if (d == Long.TYPE) */ {
                        car = 'J';
                    }
                    return sb.append(car).toString();
                } else if (d.isArray()) {
                    sb.append('[');
                    d = d.getComponentType();
                } else {
                    sb.append('L');
                    String name = d.getName();
                    int len = name.length();
                    for (int i = 0; i < len; ++i) {
                        char car = name.charAt(i);
                        sb.append(car == '.' ? '/' : car);
                    }
                    return sb.append(';').toString();
                }
            }
        }
        if (type instanceof ParameterizedType) {// 例如: Map<String, Serializable>
            ParameterizedType pt = (ParameterizedType) type;
            final StringBuilder sb = new StringBuilder();
            String raw = getTypeDescriptor(pt.getRawType());
            sb.append(raw.substring(0, raw.length() - 1)).append('<');
            for (java.lang.reflect.Type item : pt.getActualTypeArguments()) {
                sb.append(getTypeDescriptor(item));
            }
            return sb.append(">;").toString();
        }
        if (type instanceof WildcardType) { // 例如: <? extends Serializable>
            final WildcardType wt = (WildcardType) type;
            final StringBuilder sb = new StringBuilder();
            java.lang.reflect.Type[] us = wt.getUpperBounds();
            java.lang.reflect.Type[] ls = wt.getLowerBounds();
            if (ls.length < 1) {
                if (us.length == 1 && us[0] == Object.class) {
                    sb.append('*');
                } else {
                    for (java.lang.reflect.Type f : us) {
                        sb.append('+');
                        sb.append(getTypeDescriptor(f));
                    }
                }
            }
            for (java.lang.reflect.Type f : ls) {
                sb.append('-');
                sb.append(getTypeDescriptor(f));
            }
            return sb.toString();
        }
        //TypeVariable 不支持
        return null;
    }

    //-----------------------------------------------------------------------------
//    public static javax.net.ssl.SSLContext getDefaultSSLContext() {
//        return DEFAULTSSL_CONTEXT;
//    }
//
//    public static javax.net.ssl.HostnameVerifier getDefaultHostnameVerifier() {
//        return defaultVerifier;
//    }
//
//    public static Socket createDefaultSSLSocket(InetSocketAddress address) throws IOException {
//        return createDefaultSSLSocket(address.getAddress(), address.getPort());
//    }
//
//    public static Socket createDefaultSSLSocket(InetAddress host, int port) throws IOException {
//        Socket socket = DEFAULTSSL_CONTEXT.getSocketFactory().createSocket(host, port);
//        return socket;
//    }
    //
    public static String postHttpContent(String url) throws IOException {
        return remoteHttpContent("POST", url, 0, null, null).toString(StandardCharsets.UTF_8);
    }

    public static String postHttpContent(String url, int timeoutMs) throws IOException {
        return remoteHttpContent("POST", url, timeoutMs, null, null).toString(StandardCharsets.UTF_8);
    }

    public static String postHttpContent(String url, String body) throws IOException {
        return remoteHttpContent("POST", url, 0, null, body).toString(StandardCharsets.UTF_8);
    }

    public static String postHttpContent(String url, int timeoutMs, String body) throws IOException {
        return remoteHttpContent("POST", url, timeoutMs, null, body).toString(StandardCharsets.UTF_8);
    }

    public static String postHttpContent(String url, Map<String, String> headers, String body) throws IOException {
        return remoteHttpContent("POST", url, 0, headers, body).toString(StandardCharsets.UTF_8);
    }

    public static String postHttpContent(String url, int timeoutMs, Map<String, String> headers, String body) throws IOException {
        return remoteHttpContent("POST", url, timeoutMs, headers, body).toString(StandardCharsets.UTF_8);
    }

    public static String postHttpContent(String url, Charset charset) throws IOException {
        return remoteHttpContent("POST", url, 0, null, null).toString(charset.name());
    }

    public static String postHttpContent(String url, int timeoutMs, Charset charset) throws IOException {
        return remoteHttpContent("POST", url, timeoutMs, null, null).toString(charset.name());
    }

    public static String postHttpContent(String url, Charset charset, String body) throws IOException {
        return remoteHttpContent("POST", url, 0, null, body).toString(charset.name());
    }

    public static String postHttpContent(String url, int timeoutMs, Charset charset, String body) throws IOException {
        return remoteHttpContent("POST", url, timeoutMs, null, body).toString(charset.name());
    }

    public static String postHttpContent(String url, Charset charset, Map<String, String> headers, String body) throws IOException {
        return remoteHttpContent("POST", url, 0, headers, body).toString(charset.name());
    }

    public static String postHttpContent(String url, int timeoutMs, Charset charset, Map<String, String> headers, String body) throws IOException {
        return remoteHttpContent("POST", url, timeoutMs, headers, body).toString(charset.name());
    }

    public static byte[] postHttpBytesContent(String url) throws IOException {
        return remoteHttpContent("POST", url, 0, null, null).toByteArray();
    }

    public static byte[] postHttpBytesContent(String url, int timeoutMs) throws IOException {
        return remoteHttpContent("POST", url, timeoutMs, null, null).toByteArray();
    }

    public static byte[] postHttpBytesContent(String url, Map<String, String> headers, String body) throws IOException {
        return remoteHttpContent("POST", url, 0, headers, body).toByteArray();
    }

    public static byte[] postHttpBytesContent(String url, int timeoutMs, Map<String, String> headers, String body) throws IOException {
        return remoteHttpContent("POST", url, timeoutMs, headers, body).toByteArray();
    }

    public static String getHttpContent(String url) throws IOException {
        return remoteHttpContent("GET", url, 0, null, null).toString(StandardCharsets.UTF_8);
    }

    public static String getHttpContent(String url, int timeoutMs) throws IOException {
        return remoteHttpContent("GET", url, timeoutMs, null, null).toString(StandardCharsets.UTF_8);
    }

    public static String getHttpContent(String url, Map<String, String> headers, String body) throws IOException {
        return remoteHttpContent("GET", url, 0, headers, body).toString(StandardCharsets.UTF_8);
    }

    public static String getHttpContent(String url, int timeoutMs, Map<String, String> headers, String body) throws IOException {
        return remoteHttpContent("GET", url, timeoutMs, headers, body).toString(StandardCharsets.UTF_8);
    }

    public static String getHttpContent(String url, Charset charset) throws IOException {
        return remoteHttpContent("GET", url, 0, null, null).toString(charset.name());
    }

    public static String getHttpContent(String url, int timeoutMs, Charset charset) throws IOException {
        return remoteHttpContent("GET", url, timeoutMs, null, null).toString(charset.name());
    }

    public static String getHttpContent(String url, Charset charset, Map<String, String> headers, String body) throws IOException {
        return remoteHttpContent("GET", url, 0, headers, body).toString(charset.name());
    }

    public static String getHttpContent(String url, int timeoutMs, Charset charset, Map<String, String> headers, String body) throws IOException {
        return remoteHttpContent("GET", url, timeoutMs, headers, body).toString(charset.name());
    }

    public static byte[] getHttpBytesContent(String url) throws IOException {
        return remoteHttpContent("GET", url, 0, null, null).toByteArray();
    }

    public static byte[] getHttpBytesContent(String url, int timeoutMs) throws IOException {
        return remoteHttpContent("GET", url, timeoutMs, null, null).toByteArray();
    }

    public static byte[] getHttpBytesContent(String url, Map<String, String> headers, String body) throws IOException {
        return remoteHttpContent("GET", url, 0, headers, body).toByteArray();
    }

    public static byte[] getHttpBytesContent(String url, int timeoutMs, Map<String, String> headers, String body) throws IOException {
        return remoteHttpContent("GET", url, timeoutMs, headers, body).toByteArray();
    }

    public static String remoteHttpContent(HttpClient client, String method, String url, Charset charset) throws IOException {
        return remoteHttpContentAsync(client, method, url, 0, null, null).thenApply(out -> out.toString(charset == null ? StandardCharsets.UTF_8 : charset)).join();
    }

    public static String remoteHttpContent(HttpClient client, String method, String url, int timeoutMs, Charset charset) throws IOException {
        return remoteHttpContentAsync(client, method, url, timeoutMs, null, null).thenApply(out -> out.toString(charset == null ? StandardCharsets.UTF_8 : charset)).join();
    }

    public static String remoteHttpContent(HttpClient client, String method, String url, Charset charset, Map<String, String> headers) throws IOException {
        return remoteHttpContentAsync(client, method, url, 0, headers, null).thenApply(out -> out.toString(charset == null ? StandardCharsets.UTF_8 : charset)).join();
    }

    public static String remoteHttpContent(HttpClient client, String method, String url, Charset charset, Map<String, String> headers, String body) throws IOException {
        return remoteHttpContentAsync(client, method, url, 0, headers, body).thenApply(out -> out.toString(charset == null ? StandardCharsets.UTF_8 : charset)).join();
    }

    public static String remoteHttpContent(HttpClient client, String method, String url, int timeoutMs, Charset charset, Map<String, String> headers) throws IOException {
        return remoteHttpContentAsync(client, method, url, timeoutMs, headers, null).thenApply(out -> out.toString(charset == null ? StandardCharsets.UTF_8 : charset)).join();
    }

    public static String remoteHttpContent(HttpClient client, String method, String url, int timeoutMs, Charset charset, Map<String, String> headers, String body) throws IOException {
        return remoteHttpContentAsync(client, method, url, timeoutMs, headers, body).thenApply(out -> out.toString(charset == null ? StandardCharsets.UTF_8 : charset)).join();
    }

    public static byte[] remoteHttpBytesContent(HttpClient client, String method, String url, Charset charset, Map<String, String> headers, String body) throws IOException {
        return remoteHttpContentAsync(client, method, url, 0, headers, body).thenApply(out -> out.toByteArray()).join();
    }

    public static byte[] remoteHttpBytesContent(HttpClient client, String method, String url, int timeoutMs, Charset charset, Map<String, String> headers) throws IOException {
        return remoteHttpContentAsync(client, method, url, timeoutMs, headers, null).thenApply(out -> out.toByteArray()).join();
    }

    public static byte[] remoteHttpBytesContent(HttpClient client, String method, String url, int timeoutMs, Charset charset, Map<String, String> headers, String body) throws IOException {
        return remoteHttpContentAsync(client, method, url, timeoutMs, headers, body).thenApply(out -> out.toByteArray()).join();
    }

    public static ByteArrayOutputStream remoteHttpContent(String method, String url, Map<String, String> headers, String body) throws IOException {
        return remoteHttpContent(method, url, 0, headers, body);
    }

    public static ByteArrayOutputStream remoteHttpContent(String method, String url, int timeoutMs, Map<String, String> headers, String body) throws IOException {
        return remoteHttpContentAsync(method, url, timeoutMs, headers, body).join();
    }

    public static ByteArrayOutputStream remoteHttpContent(HttpClient client, String method, String url, int timeoutMs, Map<String, String> headers, String body) throws IOException {
        return remoteHttpContentAsync(client, method, url, timeoutMs, headers, body).join();
    }

    public static CompletableFuture<String> postHttpContentAsync(String url) {
        return remoteHttpContentAsync("POST", url, 0, null, null).thenApply(out -> out.toString(StandardCharsets.UTF_8));
    }

    public static CompletableFuture<String> postHttpContentAsync(String url, Map<String, String> respHeaders) {
        return remoteHttpContentAsync("POST", url, 0, null, null, respHeaders).thenApply(out -> out.toString(StandardCharsets.UTF_8));
    }

    public static CompletableFuture<String> postHttpContentAsync(String url, int timeoutMs) {
        return remoteHttpContentAsync("POST", url, timeoutMs, null, null).thenApply(out -> out.toString(StandardCharsets.UTF_8));
    }

    public static CompletableFuture<String> postHttpContentAsync(String url, int timeoutMs, Map<String, String> respHeaders) {
        return remoteHttpContentAsync("POST", url, timeoutMs, null, null, respHeaders).thenApply(out -> out.toString(StandardCharsets.UTF_8));
    }

    public static CompletableFuture<String> postHttpContentAsync(String url, String body) {
        return remoteHttpContentAsync("POST", url, 0, null, body).thenApply(out -> out.toString(StandardCharsets.UTF_8));
    }

    public static CompletableFuture<String> postHttpContentAsync(String url, String body, Map<String, String> respHeaders) {
        return remoteHttpContentAsync("POST", url, 0, null, body, respHeaders).thenApply(out -> out.toString(StandardCharsets.UTF_8));
    }

    public static CompletableFuture<String> postHttpContentAsync(String url, int timeoutMs, String body) {
        return remoteHttpContentAsync("POST", url, timeoutMs, null, body).thenApply(out -> out.toString(StandardCharsets.UTF_8));
    }

    public static CompletableFuture<String> postHttpContentAsync(String url, int timeoutMs, String body, Map<String, String> respHeaders) {
        return remoteHttpContentAsync("POST", url, timeoutMs, null, body, respHeaders).thenApply(out -> out.toString(StandardCharsets.UTF_8));
    }

    public static CompletableFuture<String> postHttpContentAsync(String url, Map<String, String> headers, String body) {
        return remoteHttpContentAsync("POST", url, 0, headers, body).thenApply(out -> out.toString(StandardCharsets.UTF_8));
    }

    public static CompletableFuture<String> postHttpContentAsync(String url, Map<String, String> headers, String body, Map<String, String> respHeaders) {
        return remoteHttpContentAsync("POST", url, 0, headers, body, respHeaders).thenApply(out -> out.toString(StandardCharsets.UTF_8));
    }

    public static CompletableFuture<String> postHttpContentAsync(String url, int timeoutMs, Map<String, String> headers, String body) {
        return remoteHttpContentAsync("POST", url, timeoutMs, headers, body).thenApply(out -> out.toString(StandardCharsets.UTF_8));
    }

    public static CompletableFuture<String> postHttpContentAsync(String url, int timeoutMs, Map<String, String> headers, String body, Map<String, String> respHeaders) {
        return remoteHttpContentAsync("POST", url, timeoutMs, headers, body, respHeaders).thenApply(out -> out.toString(StandardCharsets.UTF_8));
    }

    public static CompletableFuture<String> postHttpContentAsync(String url, Charset charset) {
        return remoteHttpContentAsync("POST", url, 0, null, null).thenApply(out -> out.toString(charset));
    }

    public static CompletableFuture<String> postHttpContentAsync(String url, Charset charset, Map<String, String> respHeaders) {
        return remoteHttpContentAsync("POST", url, 0, null, null, respHeaders).thenApply(out -> out.toString(charset));
    }

    public static CompletableFuture<String> postHttpContentAsync(String url, int timeoutMs, Charset charset) {
        return remoteHttpContentAsync("POST", url, timeoutMs, null, null).thenApply(out -> out.toString(charset));
    }

    public static CompletableFuture<String> postHttpContentAsync(String url, int timeoutMs, Charset charset, Map<String, String> respHeaders) {
        return remoteHttpContentAsync("POST", url, timeoutMs, null, null, respHeaders).thenApply(out -> out.toString(charset));
    }

    public static CompletableFuture<String> postHttpContentAsync(String url, Charset charset, String body) {
        return remoteHttpContentAsync("POST", url, 0, null, body).thenApply(out -> out.toString(charset));
    }

    public static CompletableFuture<String> postHttpContentAsync(String url, Charset charset, String body, Map<String, String> respHeaders) {
        return remoteHttpContentAsync("POST", url, 0, null, body, respHeaders).thenApply(out -> out.toString(charset));
    }

    public static CompletableFuture<String> postHttpContentAsync(HttpClient client, String url, Charset charset, String body) {
        return remoteHttpContentAsync(client, "POST", url, 0, null, body).thenApply(out -> out.toString(charset));
    }

    public static CompletableFuture<String> postHttpContentAsync(HttpClient client, String url, Charset charset, String body, Map<String, String> respHeaders) {
        return remoteHttpContentAsync(client, "POST", url, 0, null, body, respHeaders).thenApply(out -> out.toString(charset));
    }

    public static CompletableFuture<String> postHttpContentAsync(HttpClient client, String url, Map<String, String> headers, String body) {
        return remoteHttpContentAsync(client, "POST", url, 0, headers, body).thenApply(out -> out.toString(StandardCharsets.UTF_8));
    }

    public static CompletableFuture<String> postHttpContentAsync(HttpClient client, String url, Map<String, String> headers, String body, Map<String, String> respHeaders) {
        return remoteHttpContentAsync(client, "POST", url, 0, headers, body, respHeaders).thenApply(out -> out.toString(StandardCharsets.UTF_8));
    }

    public static CompletableFuture<String> postHttpContentAsync(HttpClient client, String url, Charset charset, Map<String, String> headers, String body) {
        return remoteHttpContentAsync(client, "POST", url, 0, headers, body).thenApply(out -> out.toString(charset));
    }

    public static CompletableFuture<String> postHttpContentAsync(HttpClient client, String url, Charset charset, Map<String, String> headers, String body, Map<String, String> respHeaders) {
        return remoteHttpContentAsync(client, "POST", url, 0, headers, body, respHeaders).thenApply(out -> out.toString(charset));
    }

    public static CompletableFuture<String> postHttpContentAsync(String url, int timeoutMs, Charset charset, String body) {
        return remoteHttpContentAsync("POST", url, timeoutMs, null, body).thenApply(out -> out.toString(charset));
    }

    public static CompletableFuture<String> postHttpContentAsync(String url, int timeoutMs, Charset charset, String body, Map<String, String> respHeaders) {
        return remoteHttpContentAsync("POST", url, timeoutMs, null, body, respHeaders).thenApply(out -> out.toString(charset));
    }

    public static CompletableFuture<String> postHttpContentAsync(String url, Charset charset, Map<String, String> headers, String body) {
        return remoteHttpContentAsync("POST", url, 0, headers, body).thenApply(out -> out.toString(charset));
    }

    public static CompletableFuture<String> postHttpContentAsync(String url, Charset charset, Map<String, String> headers, String body, Map<String, String> respHeaders) {
        return remoteHttpContentAsync("POST", url, 0, headers, body, respHeaders).thenApply(out -> out.toString(charset));
    }

    public static CompletableFuture<String> postHttpContentAsync(String url, int timeoutMs, Charset charset, Map<String, String> headers, String body) {
        return remoteHttpContentAsync("POST", url, timeoutMs, headers, body).thenApply(out -> out.toString(charset));
    }

    public static CompletableFuture<String> postHttpContentAsync(String url, int timeoutMs, Charset charset, Map<String, String> headers, String body, Map<String, String> respHeaders) {
        return remoteHttpContentAsync("POST", url, timeoutMs, headers, body, respHeaders).thenApply(out -> out.toString(charset));
    }

    public static CompletableFuture<byte[]> postHttpBytesContentAsync(String url) {
        return remoteHttpContentAsync("POST", url, 0, null, null).thenApply(out -> out.toByteArray());
    }

    public static CompletableFuture<byte[]> postHttpBytesContentAsync(String url, Map<String, String> respHeaders) {
        return remoteHttpContentAsync("POST", url, 0, null, null, respHeaders).thenApply(out -> out.toByteArray());
    }

    public static CompletableFuture<byte[]> postHttpBytesContentAsync(String url, int timeoutMs) {
        return remoteHttpContentAsync("POST", url, timeoutMs, null, null).thenApply(out -> out.toByteArray());
    }

    public static CompletableFuture<byte[]> postHttpBytesContentAsync(String url, int timeoutMs, Map<String, String> respHeaders) {
        return remoteHttpContentAsync("POST", url, timeoutMs, null, null, respHeaders).thenApply(out -> out.toByteArray());
    }

    public static CompletableFuture<byte[]> postHttpBytesContentAsync(String url, Map<String, String> headers, String body) {
        return remoteHttpContentAsync("POST", url, 0, headers, body).thenApply(out -> out.toByteArray());
    }

    public static CompletableFuture<byte[]> postHttpBytesContentAsync(String url, Map<String, String> headers, String body, Map<String, String> respHeaders) {
        return remoteHttpContentAsync("POST", url, 0, headers, body, respHeaders).thenApply(out -> out.toByteArray());
    }

    public static CompletableFuture<byte[]> postHttpBytesContentAsync(String url, int timeoutMs, Map<String, String> headers, String body) {
        return remoteHttpContentAsync("POST", url, timeoutMs, headers, body).thenApply(out -> out.toByteArray());
    }

    public static CompletableFuture<byte[]> postHttpBytesContentAsync(String url, int timeoutMs, Map<String, String> headers, String body, Map<String, String> respHeaders) {
        return remoteHttpContentAsync("POST", url, timeoutMs, headers, body, respHeaders).thenApply(out -> out.toByteArray());
    }

    public static CompletableFuture<String> getHttpContentAsync(String url) {
        return remoteHttpContentAsync("GET", url, 0, null, null).thenApply(out -> out.toString(StandardCharsets.UTF_8));
    }

    public static CompletableFuture<String> getHttpContentAsync(String url, Map<String, String> respHeaders) {
        return remoteHttpContentAsync("GET", url, 0, null, null, respHeaders).thenApply(out -> out.toString(StandardCharsets.UTF_8));
    }

    public static CompletableFuture<String> getHttpContentAsync(String url, int timeoutMs) {
        return remoteHttpContentAsync("GET", url, timeoutMs, null, null).thenApply(out -> out.toString(StandardCharsets.UTF_8));
    }

    public static CompletableFuture<String> getHttpContentAsync(String url, int timeoutMs, Map<String, String> respHeaders) {
        return remoteHttpContentAsync("GET", url, timeoutMs, null, null, respHeaders).thenApply(out -> out.toString(StandardCharsets.UTF_8));
    }

    public static CompletableFuture<String> getHttpContentAsync(String url, Map<String, String> headers, String body) {
        return remoteHttpContentAsync("GET", url, 0, headers, body).thenApply(out -> out.toString(StandardCharsets.UTF_8));
    }

    public static CompletableFuture<String> getHttpContentAsync(String url, Map<String, String> headers, String body, Map<String, String> respHeaders) {
        return remoteHttpContentAsync("GET", url, 0, headers, body, respHeaders).thenApply(out -> out.toString(StandardCharsets.UTF_8));
    }

    public static CompletableFuture<String> getHttpContentAsync(String url, int timeoutMs, Map<String, String> headers, String body) {
        return remoteHttpContentAsync("GET", url, timeoutMs, headers, body).thenApply(out -> out.toString(StandardCharsets.UTF_8));
    }

    public static CompletableFuture<String> getHttpContentAsync(String url, int timeoutMs, Map<String, String> headers, String body, Map<String, String> respHeaders) {
        return remoteHttpContentAsync("GET", url, timeoutMs, headers, body, respHeaders).thenApply(out -> out.toString(StandardCharsets.UTF_8));
    }

    public static CompletableFuture<String> getHttpContentAsync(String url, Charset charset) {
        return remoteHttpContentAsync("GET", url, 0, null, null).thenApply(out -> out.toString(charset));
    }

    public static CompletableFuture<String> getHttpContentAsync(String url, Charset charset, Map<String, String> respHeaders) {
        return remoteHttpContentAsync("GET", url, 0, null, null, respHeaders).thenApply(out -> out.toString(charset));
    }

    public static CompletableFuture<String> getHttpContentAsync(String url, int timeoutMs, Charset charset) {
        return remoteHttpContentAsync("GET", url, timeoutMs, null, null).thenApply(out -> out.toString(charset));
    }

    public static CompletableFuture<String> getHttpContentAsync(String url, int timeoutMs, Charset charset, Map<String, String> respHeaders) {
        return remoteHttpContentAsync("GET", url, timeoutMs, null, null, respHeaders).thenApply(out -> out.toString(charset));
    }

    public static CompletableFuture<String> getHttpContentAsync(String url, Charset charset, Map<String, String> headers, String body) {
        return remoteHttpContentAsync("GET", url, 0, headers, body).thenApply(out -> out.toString(charset));
    }

    public static CompletableFuture<String> getHttpContentAsync(String url, Charset charset, Map<String, String> headers, String body, Map<String, String> respHeaders) {
        return remoteHttpContentAsync("GET", url, 0, headers, body, respHeaders).thenApply(out -> out.toString(charset));
    }

    public static CompletableFuture<String> getHttpContentAsync(String url, int timeoutMs, Charset charset, Map<String, String> headers, String body) {
        return remoteHttpContentAsync("GET", url, timeoutMs, headers, body).thenApply(out -> out.toString(charset));
    }

    public static CompletableFuture<String> getHttpContentAsync(String url, int timeoutMs, Charset charset, Map<String, String> headers, String body, Map<String, String> respHeaders) {
        return remoteHttpContentAsync("GET", url, timeoutMs, headers, body, respHeaders).thenApply(out -> out.toString(charset));
    }

    public static CompletableFuture<String> getHttpContentAsync(java.net.http.HttpClient client, String url, String body, Map<String, String> respHeaders) {
        return remoteHttpContentAsync(client, "GET", url, 0, null, body, respHeaders).thenApply(out -> out.toString(StandardCharsets.UTF_8));
    }

    public static CompletableFuture<String> getHttpContentAsync(java.net.http.HttpClient client, String url, Charset charset, String body, Map<String, String> respHeaders) {
        return remoteHttpContentAsync(client, "GET", url, 0, null, body, respHeaders).thenApply(out -> out.toString(charset));
    }

    public static CompletableFuture<String> getHttpContentAsync(java.net.http.HttpClient client, String url, Charset charset, Map<String, String> headers, String body, Map<String, String> respHeaders) {
        return remoteHttpContentAsync(client, "GET", url, 0, headers, body, respHeaders).thenApply(out -> out.toString(charset));
    }

    public static CompletableFuture<byte[]> getHttpBytesContentAsync(String url) {
        return remoteHttpContentAsync("GET", url, 0, null, null).thenApply(out -> out.toByteArray());
    }

    public static CompletableFuture<byte[]> getHttpBytesContentAsync(String url, Map<String, String> respHeaders) {
        return remoteHttpContentAsync("GET", url, 0, null, null, respHeaders).thenApply(out -> out.toByteArray());
    }

    public static CompletableFuture<byte[]> getHttpBytesContentAsync(String url, int timeoutMs) {
        return remoteHttpContentAsync("GET", url, timeoutMs, null, null).thenApply(out -> out.toByteArray());
    }

    public static CompletableFuture<byte[]> getHttpBytesContentAsync(String url, int timeoutMs, Map<String, String> respHeaders) {
        return remoteHttpContentAsync("GET", url, timeoutMs, null, null, respHeaders).thenApply(out -> out.toByteArray());
    }

    public static CompletableFuture<byte[]> getHttpBytesContentAsync(String url, Map<String, String> headers, String body) {
        return remoteHttpContentAsync("GET", url, 0, headers, body).thenApply(out -> out.toByteArray());
    }

    public static CompletableFuture<byte[]> getHttpBytesContentAsync(String url, Map<String, String> headers, String body, Map<String, String> respHeaders) {
        return remoteHttpContentAsync("GET", url, 0, headers, body, respHeaders).thenApply(out -> out.toByteArray());
    }

    public static CompletableFuture<byte[]> getHttpBytesContentAsync(String url, int timeoutMs, Map<String, String> headers, String body) {
        return remoteHttpContentAsync("GET", url, timeoutMs, headers, body).thenApply(out -> out.toByteArray());
    }

    public static CompletableFuture<byte[]> getHttpBytesContentAsync(String url, int timeoutMs, Map<String, String> headers, String body, Map<String, String> respHeaders) {
        return remoteHttpContentAsync("GET", url, timeoutMs, headers, body, respHeaders).thenApply(out -> out.toByteArray());
    }

    public static CompletableFuture<byte[]> getHttpBytesContentAsync(java.net.http.HttpClient client, String url, int timeoutMs, Map<String, String> headers, String body, Map<String, String> respHeaders) {
        return remoteHttpContentAsync(client, "GET", url, timeoutMs, headers, body, respHeaders).thenApply(out -> out.toByteArray());
    }

    public static CompletableFuture<ByteArrayOutputStream> remoteHttpContentAsync(String method, String url, Map<String, String> headers, String body) {
        return remoteHttpContentAsync(method, url, 0, headers, body);
    }

    public static CompletableFuture<ByteArrayOutputStream> remoteHttpContentAsync(String method, String url, Map<String, String> headers, String body, Map<String, String> respHeaders) {
        return remoteHttpContentAsync(method, url, 0, headers, body, respHeaders);
    }

    public static CompletableFuture<ByteArrayOutputStream> remoteHttpContentAsync(String method, String url, int timeoutMs, Map<String, String> headers, String body) {
        return remoteHttpContentAsync(httpClient, method, url, timeoutMs, headers, body);
    }

    public static CompletableFuture<ByteArrayOutputStream> remoteHttpContentAsync(String method, String url, int timeoutMs, Map<String, String> headers, String body, Map<String, String> respHeaders) {
        return remoteHttpContentAsync(httpClient, method, url, timeoutMs, headers, body, respHeaders);
    }

    public static CompletableFuture<ByteArrayOutputStream> remoteHttpContentAsync(java.net.http.HttpClient client, String method, String url, int timeoutMs, Map<String, String> headers, String body) {
        return remoteHttpContentAsync(client, method, url, timeoutMs, headers, body, null);
    }

    public static CompletableFuture<ByteArrayOutputStream> remoteHttpContentAsync(java.net.http.HttpClient client, String method, String url, int timeoutMs, Map<String, String> headers, String body, Map<String, String> respHeaders) {
        java.net.http.HttpRequest.Builder builder = java.net.http.HttpRequest.newBuilder().uri(URI.create(url))
            .timeout(Duration.ofMillis(timeoutMs > 0 ? timeoutMs : 6000))
            .method(method, body == null ? java.net.http.HttpRequest.BodyPublishers.noBody() : java.net.http.HttpRequest.BodyPublishers.ofString(body));
        if (headers != null) {
            headers.forEach((n, v) -> builder.header(n, v));
        }
        java.net.http.HttpClient c = client == null ? httpClient : client;
        if (c == null) {
            clientLock.lock();
            try {
                if (httpClient == null) {
                    httpClient = java.net.http.HttpClient.newHttpClient();
                }
            } finally {
                clientLock.unlock();
            }
            c = httpClient;
        }
        return c.sendAsync(builder.build(), java.net.http.HttpResponse.BodyHandlers.ofByteArray())
            .thenCompose((java.net.http.HttpResponse<byte[]> resp) -> {
                final int rs = resp.statusCode();
                if (rs == 301 || rs == 302) {
                    Optional<String> opt = resp.headers().firstValue("Location");
                    if (opt.isPresent()) {
                        return remoteHttpContentAsync(client, method, opt.get(), timeoutMs, headers, body);
                    } else {
                        return CompletableFuture.failedFuture(new IOException(url + " httpcode = " + rs + ", but not found Localtion"));
                    }
                }
                byte[] result = resp.body();
                if (rs == 200 || result != null) {
                    if (respHeaders != null) {
                        resp.headers().map().forEach((k, l) -> {
                            if (!l.isEmpty()) {
                                respHeaders.put(k, l.get(0));
                            }
                        });
                    }
                    ByteArrayOutputStream out = new ByteArrayOutputStream();
                    if (result != null) {
                        if ("gzip".equalsIgnoreCase(resp.headers().firstValue("content-encoding").orElse(null))) {
                            try {
                                GZIPInputStream in = new GZIPInputStream(new ByteArrayInputStream(result));
                                in.transferTo(out);
                            } catch (IOException e) {
                                return CompletableFuture.failedFuture(e);
                            }
                        } else {
                            out.writeBytes(result);
                        }
                    }
                    return CompletableFuture.completedFuture(out);
                }
                return CompletableFuture.failedFuture(new RetcodeException(rs, url + " httpcode = " + rs));
            });
    }
//
//    public static ByteArrayOutputStream remoteHttpContent(SSLContext ctx, String method, String url, int timeoutMs, Map<String, String> headers, String body) throws IOException {
//        HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();
//        boolean opening = true;
//        try {
//            conn.setConnectTimeout(timeoutMs > 0 ? timeoutMs : 30000);
//            conn.setReadTimeout(timeoutMs > 0 ? timeoutMs : 30000);
//            if (conn instanceof HttpsURLConnection) {
//                HttpsURLConnection httpsconn = ((HttpsURLConnection) conn);
//                httpsconn.setSSLSocketFactory((ctx == null ? DEFAULTSSL_CONTEXT : ctx).getSocketFactory());
//                httpsconn.setHostnameVerifier(defaultVerifier);
//            }
//            conn.setRequestMethod(method);
//            if (headers != null) {
//                for (Map.Entry<String, String> en : headers.entrySet()) {
//                    conn.setRequestProperty(en.getKey(), en.getValue());
//                }
//            }
//            if (body != null && !body.isEmpty()) { //conn.getOutputStream()会将GET强制变成POST
//                conn.setDoInput(true);
//                conn.setDoOutput(true);
//                conn.getOutputStream().write(body.getBytes(UTF_8));
//            }
//            conn.connect();
//            int rs = conn.getResponseCode();
//            if (rs == 301 || rs == 302) {
//                String newurl = conn.getHeaderField("Location");
//                conn.disconnect();
//                opening = false;
//                return remoteHttpContent(ctx, method, newurl, timeoutMs, headers, body);
//            }
//            InputStream in = (rs < 400 || rs == 404) && rs != 405 ? conn.getInputStream() : conn.getErrorStream();
//            if ("gzip".equalsIgnoreCase(conn.getContentEncoding())) in = new GZIPInputStream(in);
//            ByteArrayOutputStream out = new ByteArrayOutputStream(1024);
//            byte[] bytes = new byte[1024];
//            int pos;
//            while ((pos = in.read(bytes)) != -1) {
//                out.write(bytes, 0, pos);
//            }
//            in.close();
//            return out;
//        } finally {
//            if (opening) conn.disconnect();
//        }
//    }

    public static String read(InputStream in) throws IOException {
        return read(in, StandardCharsets.UTF_8, false);
    }

    public static String readThenClose(InputStream in) throws IOException {
        return read(in, StandardCharsets.UTF_8, true);
    }

    public static String read(InputStream in, String charsetName) throws IOException {
        return read(in, Charset.forName(charsetName), false);
    }

    public static String read(InputStream in, Charset charset) throws IOException {
        return read(in, charset, false);
    }

    private static String read(InputStream in, Charset charset, boolean close) throws IOException {
        ByteArrayOutputStream out = new ByteArrayOutputStream(1024);
        byte[] bytes = new byte[1024];
        int pos;
        while ((pos = in.read(bytes)) != -1) {
            out.write(bytes, 0, pos);
        }
        if (close) {
            in.close();
        }
        return charset == null ? out.toString() : out.toString(charset);
    }

    public static ByteArrayOutputStream readStream(InputStream in) throws IOException {
        return readStream(in, false);
    }

    public static ByteArrayOutputStream readStreamThenClose(InputStream in) throws IOException {
        return readStream(in, true);
    }

    private static ByteArrayOutputStream readStream(InputStream in, boolean close) throws IOException {
        ByteArrayOutputStream out = new ByteArrayOutputStream(1024);
        byte[] bytes = new byte[1024];
        int pos;
        while ((pos = in.read(bytes)) != -1) {
            out.write(bytes, 0, pos);
        }
        if (close) {
            in.close();
        }
        return out;
    }

    public static byte[] readBytes(File file) throws IOException {
        return readBytesThenClose(new FileInputStream(file));
    }

    public static byte[] readBytes(InputStream in) throws IOException {
        return readStream(in).toByteArray();
    }

    public static byte[] readBytesThenClose(InputStream in) throws IOException {
        return readStreamThenClose(in).toByteArray();
    }
}
